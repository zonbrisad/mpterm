#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------
#
# Serial terminal
#
# File:    mpterm
# Author:
# Date:    2017-05-29
# License:
# Python:  >=3
# QT       5
#
# -----------------------------------------------------------------------
# This file is generated from pyplate Python template generator.
# Pyplate is developed by
# Peter Malmberg <peter.malmberg@gmail.com>
#

# Imports --------------------------------------------------------------------

import sys
import os
import subprocess
import traceback
import logging
import argparse
import signal
import enum
import json

# from datetime import datetime, date, time
from typing import Callable
from xmlrpc.client import Boolean

from PyQt5.QtCore import (
    Qt,
    QTimer,
    QProcess,
    QEvent,
    QObject,
)
from PyQt5.QtGui import QTextCursor, QIcon, QKeyEvent, QCloseEvent
from PyQt5.QtWidgets import (
    QApplication,
    QCheckBox,
    QMainWindow,
    QInputDialog,
    QDialog,
    QVBoxLayout,
    QHBoxLayout,
    QMenu,
    QMenuBar,
    QAction,
    QStatusBar,
    QLabel,
    QDialogButtonBox,
    QPushButton,
    QComboBox,
    QWidget,
    QLineEdit,
    QSizePolicy,
)

from PyQt5.QtSerialPort import QSerialPort, QSerialPortInfo

from dataclasses import dataclass, field
from escape import (
    Escape,
    Ascii,
    TerminalState,
    ascii,
    flag,
    escape_attribute_test,
    ascii_table,
    color_256_test,
)
from qterminalwidget import QTerminalWidget, get_key
from serialport import SerialPort, State
from aboutdialog import AboutDialog
from qedit import QHexEdit, QNumberEdit
from mppluginframe import MpPluginFrame

# Settings ------------------------------------------------------------------

# Absolute path to script itself
self_dir = os.path.abspath(os.path.dirname(sys.argv[0]))


class App:
    NAME = "mpterm"
    VERSION = "0.50"
    DESCRIPTION = "MpTerm is a simple serial terminal program, aimed at embedded systems development"
    LICENSE = ""
    AUTHOR = "Peter Malmberg"
    EMAIL = "peter.malmberg@gmail.com"
    ORG = ""
    HOME = "github.com/zonbrisad/mpterm"
    ICON = f"{self_dir}/icons/mp_icon2.png"
    MAX_LINES = 150
    RECEIVE_BUFFER = 256
    MACROS = 5
    SETTINGS_FILE = f"{self_dir}/mpterm.json"


# Definitions ---------------------------------------------------------------


class Mode(enum.Enum):
    Normal = 0
    Echo = 1


class MpTerm(enum.Enum):
    # Display modes
    Ascii = "Ascii"
    Hex = "Hex"
    AsciiHex = "AsciiHex"
    Terminal = "Terminal"

    # Newline modes
    Nl = 0
    Cr = 1
    NlCr = 2


about_html = f"""
<center><img src={App.ICON} width="54" height="54"></center>
<center><h2>{App.NAME}</h2></center>
<br>
{App.DESCRIPTION}
<br>
<hr>

<table>
  <tr>
    <td>
      <b>Version: </b>
    </td>
    <td>
      {App.VERSION}
    </td>
  </tr>
  <tr>
    <td>
      <b>Author: </b>
    </td>
    <td>
      {App.AUTHOR}
    </td/
  </tr>
  <tr>
    <td>
      <b>Email: </b>
    </td>
    <td> 
      </b><a href="{App.EMAIL}">{App.EMAIL}</a>
    </td/
  </tr>
  <tr>
    <td>
      <b>Github: </b>
    </td>
    <td> 
      <a href="{App.HOME}">{App.HOME}</a>
    </td/
    </td>
  </tr>
</table>
"""

# Code ----------------------------------------------------------------------


@dataclass
class Macro:
    name: str = ""
    text: str = ""
    hex: bool = False
    repeat: bool = False
    intervallEdit: int = 1000

    @staticmethod
    def is_hex_string(data: str) -> bool:
        try:
            Macro.hexstring_to_list(data)
        except ValueError:
            return False

        return True

    @staticmethod
    def hexstring_to_list(data: str) -> list[int]:
        tokens = data.strip().split(" ")
        lst = []
        for token in tokens:
            val = int(token, 16)
            if val < 0 or val > 255:
                raise ValueError
            lst.append(val)

        return lst

    def data(self) -> bytearray:
        if self.hex is True:
            tokens = self.text.strip().split(" ")
            hs = []
            try:
                for token in tokens:
                    h = int(token, 16)
                    hs.append(h)
            except ValueError:
                hs = []

            # print(hs)
            return bytearray(hs)
        return bytearray(self.text.replace("\\n", "\n"), "utf-8")


@dataclass
class mpProfile:
    alias: str = "default"
    port: str = ""
    bitrate: str = "38400"
    databits: str = "8"
    parity: str = "None"
    stopbits: str = "1"
    flowcontrol: str = "None"
    mode: str = MpTerm.Ascii.name
    suspend_timeout: int = 8
    ext_program: str = ""
    newline: str = "\n"
    win_x: int = 850
    win_y: int = 500
    sync_string: str = ""
    columns: int = 10
    macros: list[Macro] = field(default_factory=list)
    plugin: str = ""
    key_list = [
        "alias",
        "port",
        "bitrate",
        "databits",
        "parity",
        "stopbits",
        "flowcontrol",
        "mode",
        "suspend_timeout",
        "ext_program",
        "newline",
        "win_x",
        "win_y",
        "sync_string",
        "columns",
        "plugin",
    ]
    filename: str = ""

    def __post_init__(self):
        for nm in range(App.MACROS):
            m = Macro(name=f"M{nm}")
            self.macros.append(m)

    def set_member(self, key, dict):
        val = dict.get(key, getattr(self, key))
        logging.debug(f"{key} = {val}")
        setattr(self, key, val)

    def to_json(self) -> dict:
        jsonDict = {}
        for key in self.key_list:
            jsonDict[key] = getattr(self, key)

        macro_dicts = []
        for macro in self.macros:
            macro_dict = {}
            macro_dict["name"] = macro.name
            macro_dict["hex"] = macro.hex
            macro_dict["text"] = macro.text
            macro_dicts.append(macro_dict)
        jsonDict["macros"] = macro_dicts
        return jsonDict

    def from_json(self, jsonDict):
        for key in self.key_list:
            self.set_member(key, jsonDict)

        macro_dicts = jsonDict["macros"]
        for mc, md in zip(self.macros, macro_dicts):
            mc.name = md["name"]
            mc.text = md["text"]
            mc.hex = md["hex"]
            # print(md)

    def write(self):
        with open(self.filename, "w") as outfile:
            json.dump(self.to_json(), outfile, indent=4)

    def load(self):
        if not os.path.exists(self.filename):
            self.write()

        with open(self.filename, "r") as infile:
            jsd = json.load(infile)

        self.from_json(jsd)


class HexMode(enum.Enum):
    Length = 1
    SynchAfter = 2
    SynchBefore = 3


class HexFormater:
    def __init__(self) -> None:
        self.end = "<br>"
        self.sync_string = []
        self.mode = HexMode.Length
        self.set_mode(MpTerm.Ascii)
        self.set_columns(12)
        self.clear()

    def set_mode(self, mode: MpTerm) -> None:
        self.mode = mode
        self.index = 1

    def clear(self) -> None:
        self.index = 1
        self.sync_index = 0
        self.sync_list = []

    def append(self, chr: str) -> None:
        self.chars.append(chr)

    def append_byte(self, chd) -> None:
        if self.index >= self.max:
            self.clear()
            self.append(f"{self.get_char(chd)}<br>")
            return

        self.append(f"{self.get_char(chd)} ")
        self.index += 1

    def set_columns(self, cols: int) -> None:
        self.max = cols

    def set_sync_string(self, sync: list[int]) -> None:
        self.sync_string = sync

    def get(self, byte: int) -> str:

        if byte == 0x3C:  # Less than '<'
            return "'&lt;'"

        try:
            return ascii[byte]
        except KeyError:
            if byte < 128:
                return f"'{chr(byte)}'"
            else:
                return "---"

    def get_char(self, byte: int) -> str:
        if self.mode == MpTerm.Hex:
            return f"{byte:02x}"

        if self.mode == MpTerm.AsciiHex:
            ch = self.get(byte)
            return f"<b>{byte:02x}</b> {ch:3}"

    def format(self, data: bytearray) -> str:
        self.chars = []
        for i in range(0, data.count()):
            byte = int.from_bytes(data.at(i), "big")

            # if syncstring empty just printout
            if len(self.sync_string) == 0:
                self.append_byte(byte)
                self.sync_index = 0
                continue

            if byte == self.sync_string[self.sync_index]:
                self.sync_index += 1
            else:
                if self.sync_index > 0:
                    for i in range(self.sync_index):
                        self.append_byte(self.sync_string[i])
                self.append_byte(byte)
                self.sync_index = 0

            # sync is complete, append newline
            if self.sync_index == len(self.sync_string):
                self.sync_index = 0
                self.append("<br>")
                self.clear()
                for sbyte in self.sync_string:
                    self.append_byte(sbyte)

        return f"<pre>{''.join(self.chars)}</pre>"


class StyleS:
    normal = """
    QLineEdit:enabled {
    color:Blask;
    }
    QLineEdit:disabled {
    color:gray;
    }
    """
    error = """
    QLineEdit:enabled {
    color:Red;
    }
    QLineEdit:disabled {
    color:gray;
    }
    """
    win = "border:0"


qt_style_sheet = """
QToolTip{
    color: black;
    background-color: LightYellow;
    padding: 1px;
    border: 0px solid black;
}
"""


class QMacroButton(QWidget):
    def __init__(self, macro: Macro, parent=None):
        super().__init__()
        self.macro = macro
        self.layout = QHBoxLayout()
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.layout.setSpacing(2)
        self.setLayout(self.layout)

        self.setSizePolicy(QSizePolicy.MinimumExpanding, QSizePolicy.Minimum)

        self.macroButton = QPushButton(macro.name)
        self.macroButton.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)
        self.layout.addWidget(self.macroButton)
        self.repeatButton = QPushButton("R")
        self.repeatButton.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)

        self.layout.addWidget(self.repeatButton)


class MacroEditWidget(QWidget):
    def __init__(self, macro: Macro, parent=None):
        super().__init__()
        self.macro = macro
        self.layout = QHBoxLayout()
        self.layout.setContentsMargins(2, 2, 2, 2)
        # self.layout.setSpacing(2)
        self.setLayout(self.layout)

        self.name = QLabel(macro.name)
        self.macro_edit = QLineEdit(macro.text)
        self.macro_edit.textChanged.connect(self.macroChanged)
        self.hexModeCb = QCheckBox("Hex")
        self.hexModeCb.stateChanged.connect(self.macroChanged)
        self.repeatCb = QCheckBox("Repeat")

        self.intervallEdit = QLineEdit(str(macro.intervallEdit))
        self.intervallEdit.textChanged.connect(self.intervallChanged)
        self.intervallEdit.setMaximumWidth(40)
        # self.setMaxLength(4)
        # self.setSizePolicy(5)

        self.layout.addWidget(self.name)
        self.layout.addWidget(self.macro_edit)
        self.layout.addWidget(self.hexModeCb)
        # self.layout.addWidget(self.repeatCb)
        # self.layout.addWidget(self.intervallEdit)

    def intervallChanged(self, a0: str) -> None:
        if self.intervallEdit.text().isnumeric():
            self.intervallEdit.setStyleSheet(StyleS.normal)
        else:
            self.intervallEdit.setStyleSheet(StyleS.error)

    def update(self) -> None:
        self.macro_edit.setText(self.macro.text)
        self.hexModeCb.setChecked(self.macro.hex)

    def hex_mode(self) -> bool:
        return self.hexModeCb.isChecked()

    def hex_mode_changed(self, a0: str) -> None:
        self.macroChanged()

    def macroChanged(self) -> None:
        if self.hex_mode() is True:
            if Macro.is_hex_string(self.macro_edit.text()) is True:
                self.macro_edit.setStyleSheet(StyleS.normal)
            else:
                self.macro_edit.setStyleSheet(StyleS.error)
        else:
            self.macro_edit.setStyleSheet(StyleS.normal)

    def accept(self) -> None:
        self.macro.text = self.macro_edit.text()
        self.macro.hex = self.hexModeCb.isChecked()


class MacroDialog(QDialog):
    def __init__(self, parent, macros) -> None:
        super().__init__(parent=parent)
        self.setWindowTitle("Userdefined Macros")
        # self.setWindowIcon(QIcon(App.ICON))
        self.setMinimumWidth(600)
        self.macros = macros
        self.main_layout = QVBoxLayout()
        # self.main_layout.setSpacing(2)
        self.setLayout(self.main_layout)

        self.macro_edits = []
        for macro in self.macros:
            mew = MacroEditWidget(macro)
            self.main_layout.addWidget(mew)
            self.macro_edits.append(mew)

        self.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.buttonBox.accepted.connect(self.accept)
        self.buttonBox.rejected.connect(self.reject)
        self.main_layout.addWidget(self.buttonBox)

    def exec(self, macros) -> int:
        for macro_edit in self.macro_edits:
            macro_edit.update()

        return super().exec()

    def accept(self):
        for macro_edit in self.macro_edits:
            macro_edit.accept()

        self.close()


class MainForm(QMainWindow):
    # Handle windows close event
    def closeEvent(self, a0: QCloseEvent) -> None:
        self.save_settings()
        return super().closeEvent(a0)

    def add_label_combobox(self, label_text: str) -> QComboBox:
        label = QLabel(self.central_widget)
        label.setText(f"<b>{label_text}:</b>")
        label.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.port_layout.addWidget(label)
        combobox = QComboBox(self.central_widget)
        combobox.setEditable(False)
        combobox.setCurrentText("")
        self.port_layout.addWidget(combobox)
        return combobox

    def __init__(self, args, parent=None) -> None:
        super(MainForm, self).__init__(parent)

        self.prof = mpProfile(filename=App.SETTINGS_FILE)
        self.prof.load()

        self.serial_port = SerialPort()
        self.serial_port.setReadBufferSize(256)
        self.serial_port.readyRead.connect(self.read)

        self.resize(self.prof.win_x, self.prof.win_y)
        self.setWindowIcon(QIcon(App.ICON))
        self.setContentsMargins(2, 2, 2, 2)
        self.setStyleSheet(qt_style_sheet)

        self.central_widget = QWidget(self)
        self.setCentralWidget(self.central_widget)

        # Layouts
        self.main_layout = QVBoxLayout(self.central_widget)
        self.main_layout.setSpacing(2)
        self.main_layout.setContentsMargins(0, 0, 0, 0)

        self.middle_layout = QHBoxLayout(self.central_widget)

        # Port settings layout (above)
        self.port_layout = QHBoxLayout(self.central_widget)
        self.port_layout.setSpacing(10)
        self.port_layout.addStretch()

        # "Buttons" layout (to the left)
        self.button_layout = QVBoxLayout(self.central_widget)
        self.button_layout.addSpacing(10)

        # Terminal layout (middle)
        self.terminal_layout = QVBoxLayout(self.central_widget)

        # Macro layout (to the right)
        self.macro_layout = QVBoxLayout(self.central_widget)
        self.macro_layout.addSpacing(20)

        self.middle_layout.addLayout(self.button_layout)
        self.middle_layout.addLayout(self.terminal_layout)
        self.middle_layout.addLayout(self.macro_layout)

        self.main_layout.addLayout(self.port_layout)
        self.main_layout.addLayout(self.middle_layout)

        # Port layout widgets
        self.cb_port = self.add_label_combobox("Port")
        self.cb_bitrate = self.add_label_combobox("Bitrate")
        self.cb_bitrate.addItem("300", 300)
        self.cb_bitrate.addItem("600", 600)
        self.cb_bitrate.addItem("1200", 1200)
        self.cb_bitrate.addItem("2400", 2400)
        self.cb_bitrate.addItem("4800", 4800)
        self.cb_bitrate.addItem("9600", 9600)
        self.cb_bitrate.addItem("19200", 19200)
        self.cb_bitrate.addItem("28400", 28400)
        self.cb_bitrate.addItem("57600", 57600)
        self.cb_bitrate.addItem("115200", 115200)
        self.cb_bitrate.setCurrentIndex(5)
        self.cb_bitrate.activated.connect(self.set_sp)

        self.cb_bits = self.add_label_combobox("Bits")
        self.cb_bits.addItem("5", QSerialPort.Data5)
        self.cb_bits.addItem("6", QSerialPort.Data6)
        self.cb_bits.addItem("7", QSerialPort.Data7)
        self.cb_bits.addItem("8", QSerialPort.Data8)
        self.cb_bits.setCurrentIndex(3)
        self.cb_bits.activated.connect(self.set_sp)

        self.cb_stop_bits = self.add_label_combobox("StopBit")
        self.cb_stop_bits.addItem("1", QSerialPort.OneStop)
        self.cb_stop_bits.addItem("1.5", QSerialPort.OneAndHalfStop)
        self.cb_stop_bits.addItem("2", QSerialPort.TwoStop)
        self.cb_stop_bits.setCurrentIndex(0)
        self.cb_stop_bits.activated.connect(self.set_sp)

        self.cb_parity = self.add_label_combobox("Parity")
        self.cb_parity.addItem("None", QSerialPort.NoParity)
        self.cb_parity.addItem("Odd", QSerialPort.OddParity)
        self.cb_parity.addItem("Even", QSerialPort.EvenParity)
        self.cb_parity.setCurrentIndex(0)
        self.cb_parity.activated.connect(self.set_sp)

        self.cb_flow_control = self.add_label_combobox("HwFlow")
        self.cb_flow_control.addItem("None", QSerialPort.NoFlowControl)
        self.cb_flow_control.addItem("Hardware", QSerialPort.HardwareControl)
        self.cb_flow_control.addItem("Software", QSerialPort.SoftwareControl)
        self.cb_flow_control.setCurrentIndex(0)
        self.cb_flow_control.activated.connect(self.set_sp)
        self.port_layout.addStretch()

        # Middle layout widgets
        #
        self.terminal = QTerminalWidget(self.central_widget)
        self.terminal.setMaxLines(App.MAX_LINES)
        self.terminal_layout.addWidget(self.terminal)

        # Button layout widgets
        #
        self.bp_open = QPushButton("Open", self.central_widget)
        self.bp_open.setFixedHeight(50)
        self.bp_open.pressed.connect(self.open_port)
        self.bp_open.setToolTip("Open/Close current serial port")
        self.button_layout.addWidget(self.bp_open)

        self.cb_echo_mode = QComboBox(self.central_widget)
        self.cb_echo_mode.addItem(Mode.Normal.name, Mode.Normal)
        self.cb_echo_mode.addItem(Mode.Echo.name, Mode.Echo)
        self.button_layout.addWidget(self.cb_echo_mode)

        self.cb_display_mode = QComboBox(self.central_widget)
        self.cb_display_mode.addItem("Ascii", MpTerm.Ascii)
        self.cb_display_mode.addItem("Hex", MpTerm.Hex)
        self.cb_display_mode.addItem("Hex + Ascii", MpTerm.AsciiHex)
        self.cb_display_mode.currentIndexChanged.connect(self.mode_change)
        self.cb_display_mode.activated.connect(self.set_sp)
        self.button_layout.addWidget(self.cb_display_mode)

        self.cb_line_mode = QComboBox(self.central_widget)
        self.cb_line_mode.addItem("LF", "\n")
        self.cb_line_mode.addItem("CR", "\r")
        self.cb_line_mode.addItem("CRLF", "\r\n")
        self.button_layout.addWidget(self.cb_line_mode)

        self.ed_line_length = QNumberEdit(self.centralWidget)
        self.ed_line_length.set_value(self.prof.columns)
        self.button_layout.addWidget(self.ed_line_length)

        self.ed_synch_string = QHexEdit(self.centralWidget)
        self.ed_synch_string.setText(self.prof.sync_string)
        self.button_layout.addWidget(self.ed_synch_string)

        self.plugin_widget = MpPluginFrame(
            self.central_widget, self.serial_port, self.terminal
        )
        # self.plugin_widget = MpPluginFrame(
        #     self.central_widget, self.serial_port, self.terminal
        # )
        self.button_layout.addWidget(self.plugin_widget)
        self.button_layout.addStretch()

        # self.dtrLabel = QLabel("\u26D4 DTR")
        # self.rtsLabel = QLabel("\u26D4 RTS")

        # self.cbRTS = QCheckBox(self.central_widget)
        # self.cbRTS.setText("RTS")
        # self.cbRTS.clicked.connect(self.handle_rts)

        # self.cbDTR = QCheckBox(self.central_widget)
        # self.cbDTR.setText("DTR")
        # self.cbDTR.setCheckable(True)
        # self.cbDTR.setChecked(False)
        # self.cbDTR.setTristate(False)
        # self.cbDTR.clicked.connect(self.handle_dtr)

        self.pb_program = QPushButton("Program", self.central_widget)
        self.pb_program.pressed.connect(self.run_ext_program)
        self.button_layout.addWidget(self.pb_program)

        self.bp_suspend = QPushButton("Suspend", self.central_widget)
        self.bp_suspend.pressed.connect(self.terminal_suspend)
        self.button_layout.addWidget(self.bp_suspend)

        # self.cbProfiles = QComboBox(self.central_widget)
        # self.cbProfiles.setObjectName("cbProfiles")
        # self.cbProfiles.addItem("Default", 0)
        # self.cbProfiles.addItem("115200", 2)
        # self.cbProfiles.addItem("New...", 3)
        # self.cbProfiles.hide()
        # self.button_layout.addWidget(self.cbNewline)
        # self.button_layout.addWidget(self.cbRTS)
        # self.button_layout.addWidget(self.cbDTR)
        # self.button_layout.addWidget(self.dtrLabel)
        # self.button_layout.addWidget(self.rtsLabel)

        # Macro layout widgets
        #
        for macro in self.prof.macros:
            macro_button = QPushButton(
                macro.name,
                self.central_widget,
                pressed=lambda m=macro: self.serial_port.send(m.data()),
            )
            self.macro_layout.addWidget(macro_button)

            # macro_button = QMacroButton(macro=macro)
            # self.macro_layout.addWidget(macro_button)

        self.macro_dialog = MacroDialog(self, self.prof.macros)
        self.macro_set = QPushButton("Edit macro's", self.central_widget)
        self.macro_set.pressed.connect(self.edit_macro_dialog)

        self.macro_layout.addSpacing(20)
        self.macro_layout.addWidget(self.macro_set)
        self.macro_layout.addStretch()

        self.bp_pause = QPushButton("Pause", self.central_widget)
        self.bp_pause.pressed.connect(self.terminal_pause)
        self.macro_layout.addWidget(self.bp_pause)

        # Status bar
        self.statusbar = QStatusBar(self)
        self.statusbar.setLayoutDirection(Qt.LeftToRight)
        self.statusbar.setStyleSheet(StyleS.normal)
        self.setStatusBar(self.statusbar)

        # Status bar elements
        self.label_state = QLabel("")
        self.statusbar.addPermanentWidget(self.label_state, stretch=0)
        self.label_rx = QLabel("")
        self.statusbar.addPermanentWidget(self.label_rx, stretch=0)
        self.label_tx = QLabel("")
        self.statusbar.addPermanentWidget(self.label_tx, stretch=0)
        self.label_dimensions = QLabel("")
        # self.dimensionsLabel.setToolTip("Terminal size")
        self.statusbar.addPermanentWidget(self.label_dimensions, stretch=0)
        # self.yyy = QComboBox(self.central_widget)
        # self.yyy.addItem("80x24", Mode.Normal)
        # self.yyy.addItem("132x24", Mode.Normal)
        # self.statusbar.addPermanentWidget(self.yyy)

        # Menu bar
        self.menubar = QMenuBar(self)
        self.setMenuBar(self.menubar)

        # File menu
        self.menu_file = QMenu(self.menubar, title="&File")
        self.menubar.addAction(self.menu_file.menuAction())
        self.action_new = QAction("New", self, triggered=self.new_terminal)
        self.menu_file.addAction(self.action_new)
        self.action_exit = QAction("Quit", self, triggered=self.exit_program)
        self.action_exit.setToolTip("Quit")
        self.action_exit.setShortcutContext(Qt.WidgetShortcut)
        self.menu_file.addAction(self.action_exit)

        # self.actionEcho = QAction(
        #     "Echo", self, triggered=None, checkable=True
        # )
        # self.menuSettings.addAction(self.actionEcho)

        # Settings menu
        self.menu_settings = QMenu(self.menubar, title="Settings")
        self.menubar.addAction(self.menu_settings.menuAction())
        self.action_set_program = QAction(
            "Ext. Program", self, triggered=self.set_ext_program
        )
        self.menu_settings.addAction(self.action_set_program)
        self.action_set_timeout = QAction(
            "Suspend timeout", self, triggered=self.set_suspend_timeout
        )
        self.menu_settings.addAction(self.action_set_timeout)

        # Action menu
        self.menu_action = QMenu(self.menubar, title="&Action")
        self.menubar.addAction(self.menu_action.menuAction())
        self.action_clear = QAction(self, text="Clear")
        self.action_clear.triggered.connect(self.terminal_clear)
        self.menu_action.addAction(self.action_clear)

        self.action_reset_port = QAction(self, text="Reset port")
        self.action_port_info = QAction(
            self, text="Port info", triggered=self.port_info
        )
        self.menu_action.addAction(self.action_port_info)

        # Send menu
        self.menu_send = QMenu(self.menubar, title="Send")
        self.menubar.addAction(self.menu_send.menuAction())
        self.add_action(
            "Break [0x00]", self.menu_send, lambda: self.send_string(Ascii.NULL)
        )
        self.add_action(
            "ETX [0x03] (Ctrl-C)", self.menu_send, lambda: self.send_string(Ascii.ETX)
        )
        self.add_action(
            "EOT [0x04] (Ctrl-D)", self.menu_send, lambda: self.send_string(Ascii.ETX)
        )
        self.add_action(
            "Tab [0x09]", self.menu_send, lambda: self.send_string(Ascii.TAB)
        )
        self.add_action("LF [0x0a]", self.menu_send, lambda: self.send_string(Ascii.NL))
        self.add_action("CR [0x0d]", self.menu_send, lambda: self.send_string(Ascii.CR))

        self.menu_tests = self.menu_send.addMenu("Tests")

        sendAsciiTableAction = QAction("Ascii table", self)
        sendAsciiTableAction.triggered.connect(lambda: self.send_string(ascii_table()))
        self.menu_tests.addAction(sendAsciiTableAction)

        sendTestAction = QAction("Escape test", self)
        sendTestAction.triggered.connect(
            lambda: self.send_string(escape_attribute_test)
        )
        self.menu_tests.addAction(sendTestAction)

        sendFlagAction = QAction("Flag SE", self)
        sendFlagAction.triggered.connect(lambda: self.send_string(flag))
        self.menu_tests.addAction(sendFlagAction)

        colorAction = QAction("Color test", self)
        colorAction.triggered.connect(lambda: self.send_string(color_256_test()))
        self.menu_tests.addAction(colorAction)

        self.menu_color = self.menu_send.addMenu("Colors")
        self.add_action("Red", self.menu_color, lambda: self.send_string(Escape.RED))
        self.add_action(
            "Green", self.menu_color, lambda: self.send_string(Escape.GREEN)
        )
        self.add_action(
            "Yellow", self.menu_color, lambda: self.send_string(Escape.YELLOW)
        )
        self.add_action("Blue", self.menu_color, lambda: self.send_string(Escape.BLUE))
        self.add_action(
            "Magenta", self.menu_color, lambda: self.send_string(Escape.MAGENTA)
        )
        self.add_action("Cyan", self.menu_color, lambda: self.send_string(Escape.CYAN))
        self.add_action(
            "White", self.menu_color, lambda: self.send_string(Escape.WHITE)
        )

        self.add_action(
            "Bg Red", self.menu_color, lambda: self.send_string(Escape.BG_RED)
        )
        self.add_action(
            "Bg Green", self.menu_color, lambda: self.send_string(Escape.BG_GREEN)
        )
        self.add_action(
            "Bg Yellow", self.menu_color, lambda: self.send_string(Escape.BG_YELLOW)
        )
        self.add_action(
            "Bg Blue", self.menu_color, lambda: self.send_string(Escape.BG_BLUE)
        )
        self.add_action(
            "Bg Magenta", self.menu_color, lambda: self.send_string(Escape.BG_MAGENTA)
        )
        self.add_action(
            "Bg Cyan", self.menu_color, lambda: self.send_string(Escape.BG_CYAN)
        )
        self.add_action(
            "Bg White", self.menu_color, lambda: self.send_string(Escape.BG_WHITE)
        )

        self.menu_attr = self.menu_send.addMenu("Attributes")
        self.add_action("Reset", self.menu_attr, lambda: self.send_string(Escape.RESET))
        self.add_action("Bold", self.menu_attr, lambda: self.send_string(Escape.BOLD))
        self.add_action(
            "Italic", self.menu_attr, lambda: self.send_string(Escape.ITALIC)
        )
        self.add_action("Dim", self.menu_attr, lambda: self.send_string(Escape.DIM))
        self.add_action(
            "Reverse", self.menu_attr, lambda: self.send_string(Escape.REVERSE)
        )
        self.add_action(
            "Underline", self.menu_attr, lambda: self.send_string(Escape.UNDERLINE)
        )
        self.add_action(
            "Crossed", self.menu_attr, lambda: self.send_string(Escape.CROSSED)
        )

        self.menu_attr = self.menu_send.addMenu("Cursor")
        self.add_action("Up", self.menu_attr, lambda: self.send_string(Escape.UP))
        self.add_action("Down", self.menu_attr, lambda: self.send_string(Escape.DOWN))
        self.add_action(
            "Forward", self.menu_attr, lambda: self.send_string(Escape.FORWARD)
        )
        self.add_action(
            "Backward",
            self.menu_attr,
            lambda: self.send_string(Escape.BACK),
        )

        # Plugin menu
        self.menu_plugins = QMenu(self.menubar, title="Plugins")
        self.menubar.addAction(self.menu_plugins.menuAction())
        self.action_list_plugins = QAction(self, text="List plugins")
        self.action_list_plugins.triggered.connect(
            lambda: self.append_html_text(self.plugin_widget.plugins_to_str())
        )
        self.menu_plugins.addAction(self.action_list_plugins)

        # Help menu
        self.menu_help = QMenu(self.menubar, title="&Help")
        self.menubar.addAction(self.menu_help.menuAction())
        self.action_about = QAction(self, text="About")
        self.action_about.triggered.connect(
            lambda: AboutDialog.about(App.NAME, about_html)
        )
        self.menu_help.addAction(self.action_about)

        # Scan for serialports
        self.update_ports()
        self.formater = HexFormater()

        self.load_settings()
        self.mode_change()

        # If commandline argument use it instead of saved parameter
        if args.ext_program != "":
            self.prof.ext_program = args.ext_program

        # Configure signal handler
        signal.signal(signal.SIGUSR1, self.signal_usr1)
        signal.signal(signal.SIGUSR2, self.signal_usr2)

        # Timers
        self.timer = QTimer()
        self.timer.setInterval(1000)
        self.timer.timeout.connect(self.timer_event)
        self.timer.start()

        self.timer_5 = QTimer()
        self.timer_5.setInterval(200)
        self.timer_5.timeout.connect(self.timer_5_timeout)
        self.timer_5.start()

        self.ts = TerminalState()

        self.process = QProcess()
        self.process.readyReadStandardOutput.connect(self.program_stdout_available)
        self.process.readyReadStandardError.connect(self.program_stderr_available)
        self.process.finished.connect(self.program_finished)

        self.terminal_paused = False

        self.terminal.installEventFilter(self)
        self.terminal.append_html_text(f"""MpTerm Ver: <b>{App.VERSION}</b><br><br>""")

        self.update_ui()
        self.init_port()

    def edit_macro_dialog(self) -> None:
        self.macro_dialog.exec(self.prof.macros)

    def set_suspend_timeout(self) -> None:
        dlg = QInputDialog()
        val, ok = dlg.getInt(
            self, "Suspend timeout", "Timeout (s)", value=self.prof.suspend_timeout
        )

        if ok is True:
            self.prof.suspend_timeout = val

    def set_ext_program(self) -> None:
        dlg = QInputDialog()
        val, ok = dlg.getText(
            self,
            "External program",
            "Commandline:",
            text=self.prof.ext_program,
        )

        self.prof.ext_program = val

    def keyPressEvent(self, e: QKeyEvent) -> None:
        super().keyPressEvent(e)
        # logging.debug(f"  {e.key():name}  {get_description(e)}")
        self.serial_port.send_string(get_key(e))

    def eventFilter(self, obj: QObject, event: QEvent) -> bool:
        key2key = {
            Qt.Key_Tab: Ascii.TAB,
            Qt.Key_Left: Escape.BACK,
            Qt.Key_Right: Escape.FORWARD,
            Qt.Key_Up: Escape.UP,
            Qt.Key_Down: Escape.DOWN,
            Qt.Key_Delete: Escape.KEY_DELETE,
            Qt.Key_Space: " ",
            Qt.Key_Enter: "",
            Qt.Key_Return: "",
        }
        # logging.debug(f"Event: {event}")
        # print(event.type())
        if event.type() == QEvent.KeyPress:
            keyEvent = QKeyEvent(event)
            if keyEvent.key() in [Qt.Key_Enter, Qt.Key_Return]:
                self.serial_port.send_string(self.cb_line_mode.currentData())
                return True

            if keyEvent.key() in key2key:
                logging.debug(f"Key:{keyEvent.key()}")
                self.serial_port.send_string(key2key[keyEvent.key()])
                return True
            else:
                return False
        return False

    def send_macro(self, macro: Macro) -> None:
        self.serial_port.send(macro.data())

    # def key(self, e: QKeyEvent) -> None:
    #     # logging.debug(f"  {e.key():name}  {get_description(e)}")
    #     # self.sp.send_string(get_key(e))
    #     print("Keypressed")

    def add_action(self, name: str, menu: QMenu, function: Callable) -> QAction:
        action = QAction(name, self)
        menu.addAction(action)
        action.triggered.connect(function)
        return action

    def terminal_pause(self) -> None:
        if self.terminal_paused is True:
            self.terminal_paused = False
        else:
            self.terminal_paused = True

    def terminal_suspend(self) -> None:
        logging.debug(f"Suspending port for {self.prof.suspend_timeout} s.")
        self.serial_port.set_state(
            State.SUSPENDED, timeout=self.prof.suspend_timeout * 1000
        )
        self.update_ui()

    def program_stdout_available(self) -> None:
        logging.debug("Program received stdout data")
        data = self.process.readAllStandardOutput()
        data_str = str(data, "utf-8")
        self.terminal.append_ansi_text(data_str)
        self.terminal.scroll_down()
        self.update_ui()

    def program_stderr_available(self) -> None:
        logging.debug("Program received stderr data")
        data = self.process.readAllStandardError()
        data_str = str(data, "utf-8")
        self.terminal.append_ansi_text(data_str)
        self.terminal.scroll_down()
        self.update_ui()

    def program_finished(self) -> None:
        logging.debug("External program finnished executing")
        self.terminal.append_html_text("<br>")
        if self.serial_port.state == State.SUSPENDED:
            self.serial_port.set_state(State.RECONNECTING)
        self.update_ui()

    def run_ext_program(self) -> None:
        if self.serial_port.state == State.SUSPENDED:
            return

        if self.serial_port.state == State.CONNECTED:
            self.serial_port.set_state(State.SUSPENDED, timeout=-1)

        self.terminal.append_html_text("<br>")
        ext_prog = self.prof.ext_program.replace(
            "__PORT__", f"/dev/{self.serial_port.portName()}"
        )
        self.process.start(ext_prog)
        logging.debug(
            f"Runing external run_ext_program: {ext_prog}  {self.process.processId()}"
        )
        self.update_ui()
        self.terminal.scroll_down()

    def signal_usr1(self, signum, frame) -> None:
        logging.debug("USR1 signal received")
        self.terminal_suspend()

    def signal_usr2(self, signum, frame) -> None:
        logging.debug("USR2 signal received")
        self.run_ext_program()

    def timer_5_timeout(self) -> None:
        self.update_ui()

    def port_handler(self) -> None:
        portNames = [name.portName() for name in QSerialPortInfo.availablePorts()]

        # Check if current port is still connecter (USB to serial adapters), if not close port
        if self.serial_port.isOpen():
            if self.serial_port.portName() not in portNames:
                self.serial_port.close()
                self.message_error(
                    f"Port {self.serial_port.portName()} no longer available."
                )

        # Update list of serialports in combobox
        for name in range(self.cb_port.count()):
            if self.cb_port.itemText(name) not in portNames:
                self.cb_port.removeItem(name)
            else:
                portNames.remove(self.cb_port.itemText(name))

        for name in portNames:
            self.cb_port.addItem(name)

    def timer_event(self) -> None:
        self.port_handler()

    def update_ui(self) -> None:
        if self.serial_port.state == State.DISCONNECTED:
            self.setWindowTitle("MpTerm")
            self.bp_open.setText("Open")
            self.cb_port.setEnabled(True)
        else:
            self.setWindowTitle(
                f"MpTerm  /dev/{self.cb_port.currentText()} {self.cb_bitrate.currentText()}"
            )
            self.bp_open.setText("Close")
            self.cb_port.setEnabled(False)

        self.label_rx.setText(
            f'<span style="color:Black">RX:</span> <span style="color:Purple">{self.serial_port.cnt_rx:06d}</span> '
        )
        self.label_tx.setText(
            f'<span style="color:Black">TX:</span> <span style="color:Purple">{self.serial_port.cnt_tx:06d}</span> '
        )
        self.label_dimensions.setText(
            f'<span style="color:Black">{self.terminal.terminal_state.max.column:3d}x{self.terminal.terminal_state.max.row:2d}</span> '
        )

        states = {
            State.DISCONNECTED: f"""<span style="color:Black">Disconected</span>""",
            State.CONNECTED: f"""<span style="color:Green">Connected  </span>""",
            State.SUSPENDED: f"""<span style="color:Red">Suspended {self.serial_port.suspend_timer.remainingTime()/1000:.0f}</span>""",
            State.RECONNECTING: f"""<span style="color:Magenta">Reconnecting {self.serial_port.cntReconnect}</span>""",
        }
        self.label_state.setText(f"{states[self.serial_port.state]}")

        if self.terminal_paused is True:
            self.bp_pause.setText("Paused")
        else:
            self.bp_pause.setText("Pause")

        self.formater.set_columns(self.ed_line_length.get_value())
        self.formater.set_sync_string(self.ed_synch_string.get_value())

        if self.plugin_widget.current_plugin() is None:
            self.cb_echo_mode.setEnabled(True)
            self.cb_display_mode.setEnabled(True)
            self.cb_line_mode.setEnabled(True)
            self.ed_line_length.setEnabled(True)
            self.ed_synch_string.setEnabled(True)
        else:
            self.cb_echo_mode.setEnabled(False)
            self.cb_display_mode.setEnabled(False)
            self.cb_line_mode.setEnabled(False)
            self.ed_line_length.setEnabled(False)
            self.ed_synch_string.setEnabled(False)

        # if self.serial_port.isDataTerminalReady():
        #     self.dtrLabel.setText("\u26AA  DTR")
        # else:
        #     self.dtrLabel.setText("\u26AB  DTR")

        # if self.serial_port.isRequestToSend():
        #     self.rtsLabel.setText("\u26AA  RTS")
        # else:
        #     self.rtsLabel.setText("\u26AB  RTS")

        # logging.debug(f"DTR: {self.sp.serial_port.isDataTerminalReady()}  RTS: {self.sp.serial_port.isRequestToSend()}")

    def update_ports(self) -> None:
        ports = QSerialPortInfo.availablePorts()
        for port in ports:
            self.cb_port.addItem(port.portName())

    def handle_dtr(self) -> None:
        # self.ui.cbDTR.clicked.connect(self.handle_dtr)
        logging.debug("DTR")
        if self.cbDTR.isChecked():
            self.cbDTR.setChecked(True)
            self.serial_port.setDataTerminalReady(True)
        else:
            self.cbDTR.setChecked(False)
            self.serial_port.setDataTerminalReady(False)

    def handle_rts(self) -> None:
        logging.debug("RTS")
        if self.cbRTS.isChecked():
            self.cbRTS.setChecked(True)
            self.serial_port.setRequestToSend(True)
        else:
            self.cbRTS.setChecked(False)
            self.serial_port.setRequestToSend(False)

    def terminal_clear(self) -> None:
        self.terminal.clear()
        self.formater.clear()
        self.serial_port.clear_counters()
        self.update()

    def _message(self, name: str) -> None:
        self.statusbar.showMessage(name, 4000)
        self.statusbar.show

    # Show message in status bar
    def message(self, name: str) -> None:
        self.statusbar.setStyleSheet(StyleS.normal)
        self._message(name)
        logging.debug(name)

    # Show error message in status bar
    def message_error(self, name: str) -> None:
        self.statusbar.setStyleSheet(StyleS.error)
        self._message(name)
        logging.error(name)

    def mode_change(self) -> None:
        self.terminal.clear()
        self.formater.set_mode(self.cb_display_mode.currentData())
        logging.debug(f"Setting display mode {self.cb_display_mode.currentData()}")

    def append_html_text(self, text: str) -> None:
        self.terminal.append_html_text(text)
        self.terminal.scroll_down()

    def read(self) -> None:
        data = self.serial_port.read()
        try:
            data_str = str(data, "utf-8")
        except UnicodeDecodeError:
            data_str = ""
            pass

        logging.debug(f'Data received: {len(data)} "{Escape.to_str(data_str)}"')

        if self.terminal_paused:
            self.update_ui()
            return

        plugin = self.plugin_widget.current_plugin()
        if plugin is not None:
            self.terminal.append_html_text(plugin.data(data))
        else:
            DisplayMode = self.cb_display_mode.currentData()
            if DisplayMode == MpTerm.Ascii:  # Standard ascii display mode
                self.terminal.append_ansi_text(data_str)

            if DisplayMode == MpTerm.AsciiHex:  # Ascii + Hex display mode
                self.terminal.append_html_text(self.formater.format(data))

            if DisplayMode == MpTerm.Hex:  # Hexadecimal display mode
                self.terminal.append_html_text(self.formater.format(data))

        if self.cb_echo_mode.currentData() == Mode.Echo:
            self.serial_port.send(data)

        self.terminal.scroll_down()
        self.update_ui()

    def send(self, data: bytearray) -> None:
        if self.serial_port.isOpen():
            res = self.serial_port.write(data)
            if res > 0:
                self.serial_port.txCnt += res
            else:
                logging.error("Could not write data.")
            self.update_ui()

    def send_string(self, data: str) -> None:
        self.send(bytearray(data, "utf-8"))

    def open_port(self) -> None:
        if self.serial_port.isOpen():
            self.serial_port.close()
            self.update_ui()
            return

        self.serial_port.clear()
        self.init_port()
        res = self.serial_port.open()
        if res:
            self.message(
                f"Opening port: /dev/{self.serial_port.portName()} {self.serial_port.baudRate()}"
            )
        else:
            self.message_error(
                f"Failed to open port /dev/{self.serial_port.portName()}. {self.serial_port.error()}"
            )

        self.update_ui()

    def init_port(self) -> None:
        self.set_port()
        self.set_sp()

    def set_port(self) -> None:
        self.serial_port.setPortName(f"/dev/{self.cb_port.currentText()}")

    def set_sp(self) -> None:
        self.serial_port.setBaudRate(self.cb_bitrate.currentData())
        self.serial_port.setStopBits(self.cb_stop_bits.currentData())
        self.serial_port.setDataBits(self.cb_bits.currentData())
        self.serial_port.setParity(self.cb_parity.currentData())
        self.serial_port.setFlowControl(self.cb_flow_control.currentData())
        logging.debug(self.cb_bitrate.currentData())

    def save_settings(self) -> None:
        self.prof.port = self.cb_port.currentText()
        self.prof.bitrate = self.cb_bitrate.currentText()
        self.prof.databits = self.cb_bits.currentText()
        self.prof.stopbits = self.cb_stop_bits.currentText()
        self.prof.parity = self.cb_parity.currentText()
        self.prof.flowcontrol = self.cb_flow_control.currentText()
        self.prof.mode = self.cb_display_mode.currentData().name
        self.prof.newline = self.cb_line_mode.currentText()
        self.prof.win_x = self.width()
        self.prof.win_y = self.height()
        self.prof.sync_string = self.ed_synch_string.text()
        self.prof.columns = self.ed_line_length.get_value()
        self.prof.plugin = self.plugin_widget.current_plugin_name()
        self.prof.write()

    def load_cb_setting(self, cb: QComboBox, setting: str) -> None:
        idx = cb.findText(setting)
        if idx != -1:
            cb.setCurrentIndex(idx)

    def load_settings(self) -> None:
        self.load_cb_setting(self.cb_bitrate, self.prof.bitrate)
        self.load_cb_setting(self.cb_bitrate, self.prof.bitrate)
        self.load_cb_setting(self.cb_port, self.prof.port)
        self.load_cb_setting(self.cb_stop_bits, self.prof.stopbits)
        self.load_cb_setting(self.cb_bits, self.prof.databits)
        self.load_cb_setting(self.cb_parity, self.prof.parity)
        self.load_cb_setting(self.cb_flow_control, self.prof.flowcontrol)
        self.load_cb_setting(self.cb_line_mode, self.prof.newline)

        idx = self.cb_display_mode.findData(MpTerm(self.prof.mode))
        self.cb_display_mode.setCurrentIndex(idx)

        self.plugin_widget.set_plugin(self.prof.plugin)

    def exit_program(self, e) -> None:
        self.serial_port.close()
        self.close()

    def port_info(self) -> None:
        self.append_html_text("<br>")
        self.append_html_text(
            "<b><pre> Port      Location      Vendor id  Product id  Manufacturer  Description<br></pre></b>"
        )
        ports = QSerialPortInfo.availablePorts()
        for port in ports:
            self.append_html_text(
                f"<pre> {port.portName():8}  {port.systemLocation():13} {str(port.vendorIdentifier()):10} {str(port.productIdentifier()):10}  {port.manufacturer():12}  {port.description()}<br></pre>"
            )

        self.append_html_text("<br>")

    def new_terminal(self) -> None:
        subprocess.Popen([f"{self_dir}/mpterm"], shell=False)


def list_ports() -> None:
    spi = QSerialPortInfo.availablePorts()
    for p in spi:
        print(f"{p.portName():<10}{p.description():<20}{p.systemLocation()}")


def main() -> None:
    logging_format = "[%(levelname)s] %(lineno)4d %(funcName)-16s : %(message)s"

    # options parsing
    parser = argparse.ArgumentParser(
        prog=App.NAME, add_help=True, description=App.DESCRIPTION
    )
    parser.add_argument(
        "--version", action="version", version=f"%(prog)s {App.VERSION}"
    )
    parser.add_argument("--info", action="store_true", help="Information about script")
    parser.add_argument(
        "--suspend", action="store_true", help="Send signal to suspend port temporary"
    )
    parser.add_argument("--list", action="store_true", help="List serialports")
    parser.add_argument("--debug", action="store_true", help="Activate debug printout")
    parser.add_argument(
        "--ext-program",
        action="store",
        type=str,
        dest="ext_program",
        help="Set external program to execute when signaled",
        default="",
    )
    parser.add_argument(
        "--exec-program",
        action="store_true",
        help="Send signal to initiate external program execution",
    )

    args = parser.parse_args()

    if args.debug:
        logging.basicConfig(format=logging_format, level=logging.DEBUG)

    if args.list:
        list_ports()
        sys.exit()

    if args.suspend:
        with os.popen("ps aux | grep mpterm | grep -v -e 'grep' -e '--suspend'") as f:
            res = f.readlines()

        for r in res:
            pid = int(r.split()[1])
            logging.debug(f"Sending suspend signal to process pid={pid}")
            os.kill(pid, signal.SIGUSR1)

        sys.exit()

    if args.exec_program:
        with os.popen(
            "ps aux | grep mpterm | grep -v -e 'grep' -e '--exec-program'"
        ) as f:
            res = f.readlines()

        for r in res:
            pid = int(r.split()[1])
            logging.debug(f"Sending suspend signal to process pid={pid}")
            os.kill(pid, signal.SIGUSR2)

        sys.exit()

    app = QApplication(sys.argv)
    app.setStyle(
        "Fusion"
    )  # 'cleanlooks', 'gtk2', 'cde', 'motif', 'plastique', 'qt5ct-style', 'Windows', 'Fusion'
    app.setAttribute(Qt.AA_UseHighDpiPixmaps)

    mainForm = MainForm(args)
    mainForm.args = args
    mainForm.show()

    sys.exit(app.exec_())


# Main run_ext_program handle
if __name__ == "__main__":
    try:
        main()
        sys.exit(0)
    except KeyboardInterrupt as e:  # Ctrl-C
        raise e
    except SystemExit as e:  # sys.exit()
        raise e
    except Exception as e:
        print("ERROR, UNEXPECTED EXCEPTION")
        print(str(e))
        traceback.print_exc()
        os._exit(1)

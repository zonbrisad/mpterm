#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------
#
# Serial terminal
#
# File:    mpterm
# Author:
# Date:    2017-05-29
# License:
# Python:  >=3
# QT       5
#
# -----------------------------------------------------------------------
# This file is generated from pyplate Python template generator.
# Pyplate is developed by
# Peter Malmberg <peter.malmberg@gmail.com>
#

# Imports --------------------------------------------------------------------

from re import ASCII
import sys
import os
import subprocess
from tkinter import NO
import traceback
import logging
import argparse
import signal
import enum
import json
from datetime import datetime, date, time
from xmlrpc.client import Boolean

from PyQt5.QtCore import (
    Qt,
    QTimer,
    QProcess,
    QEvent,
    QObject,
)
from PyQt5.QtGui import QTextCursor, QIcon, QKeyEvent, QCloseEvent
from PyQt5.QtWidgets import (
    QApplication,
    QCheckBox,
    QMainWindow,
    QInputDialog,
    QDialog,
    QVBoxLayout,
    QHBoxLayout,
    QFormLayout,
    QMenu,
    QMenuBar,
    QAction,
    QStatusBar,
    QLabel,
    QDialogButtonBox,
    QPushButton,
    QComboBox,
    QWidget,
    QLineEdit,
    QSizePolicy,
)

from PyQt5.QtSerialPort import QSerialPort, QSerialPortInfo

# from ui_MainWindow import Ui_MainWindow
from dataclasses import dataclass, field
from escape import (
    Escape,
    Ascii,
    TerminalState,
    flag,
    escape_attribute_test,
    color_256_test,
    hex2str,
)
from qterminalwidget import QTerminalWidget, get_key
from serialport import SerialPort, State

from aboutdialog import AboutDialog

# Settings ------------------------------------------------------------------

# Absolute path to script itself
self_dir = os.path.abspath(os.path.dirname(sys.argv[0]))


class App:
    NAME = "mpterm"
    VERSION = "0.41"
    DESCRIPTION = "MpTerm is a simple serial terminal program, aimed at embedded systems development"
    LICENSE = ""
    AUTHOR = "Peter Malmberg"
    EMAIL = "peter.malmberg@gmail.com"
    ORG = ""
    HOME = "github.com/zonbrisad/mpterm"
    ICON = f"{self_dir}/icons/mp_icon2.png"
    MAX_LINES = 150
    RECEIVE_BUFFER = 256
    MACROS = 5
    SETTINGS_FILE = f"{self_dir}/mpterm.json"


# mp_settings = f"{self_dir}/mpterm.json"

# Definitions ---------------------------------------------------------------


class Mode(enum.Enum):
    Normal = 0
    Echo = 1


class MpTerm(enum.Enum):
    # Display modes
    Ascii = "Ascii"
    Hex = "Hex"
    AsciiHex = "AsciiHex"
    Terminal = "Terminal"

    # Newline modes
    Nl = 0
    Cr = 1
    NlCr = 2


about_html = f"""
<center><img src={App.ICON} width="54" height="54"></center>
<center><h2>{App.NAME}</h2></center>
<br>
{App.DESCRIPTION}
<br>
<hr>

<table>
  <tr>
    <td>
      <b>Version: </b>
    </td>
    <td>
      {App.VERSION}
    </td>
  </tr>
  <tr>
    <td>
      <b>Author: </b>
    </td>
    <td>
      {App.AUTHOR}
    </td/
  </tr>
  <tr>
    <td>
      <b>Email: </b>
    </td>
    <td> 
      </b><a href="{App.EMAIL}">{App.EMAIL}</a>
    </td/
  </tr>
  <tr>
    <td>
      <b>Github: </b>
    </td>
    <td> 
      <a href="{App.HOME}">{App.HOME}</a>
    </td/
    </td>
  </tr>
</table>
"""

# Code ----------------------------------------------------------------------


@dataclass
class Macro:
    name: str = ""
    text: str = ""
    hex: bool = False
    repeat: bool = False
    intervallEdit: int = 1000

    @staticmethod
    def is_hex_string(data: str) -> Boolean:
        tokens = data.strip().split(" ")
        try:
            for token in tokens:
                val = int(token, 16)
                if val < 0 or val > 255:
                    raise ValueError
        except ValueError:
            return False

        return True

    def data(self) -> bytearray:
        if self.hex is True:
            tokens = self.text.strip().split(" ")
            hs = []
            try:
                for token in tokens:
                    h = int(token, 16)
                    hs.append(h)
            except ValueError:
                hs = []

            # print(hs)
            return bytearray(hs)
        return bytearray(self.text.replace("\\n", "\n"), "utf-8")


@dataclass
class mpProfile:
    alias: str = "default"
    port: str = ""
    bitrate: str = "38400"
    databits: str = "8"
    parity: str = "None"
    stopbits: str = "1"
    flowcontrol: str = "None"
    mode: str = MpTerm.Ascii.name
    suspend_timeout: int = 8
    ext_program: str = ""
    newline: str = "\n"
    win_x: int = 850
    win_y: int = 500
    macros: list[Macro] = field(default_factory=list)
    key_list = [
        "alias",
        "port",
        "bitrate",
        "databits",
        "parity",
        "stopbits",
        "flowcontrol",
        "mode",
        "suspend_timeout",
        "ext_program",
        "newline",
        "win_x",
        "win_y",
    ]
    filename: str = ""

    def __post_init__(self):
        for nm in range(App.MACROS):
            # for nm in ["M1", "M2", "M3", "M4", "M5"]:
            # m = Macro(name=nm)
            m = Macro(name=f"M{nm}")
            self.macros.append(m)

    def set_member(self, key, dict):
        val = dict.get(key, getattr(self, key))
        logging.debug(f"{key} = {val}")
        setattr(self, key, val)

    def to_json(self) -> dict:
        jsonDict = {}
        for key in self.key_list:
            jsonDict[key] = getattr(self, key)

        macro_dicts = []
        for macro in self.macros:
            macro_dict = {}
            macro_dict["name"] = macro.name
            macro_dict["hex"] = macro.hex
            macro_dict["text"] = macro.text
            macro_dicts.append(macro_dict)
        jsonDict["macros"] = macro_dicts
        return jsonDict

    def from_json(self, jsonDict):
        for key in self.key_list:
            self.set_member(key, jsonDict)

        macro_dicts = jsonDict["macros"]
        for mc, md in zip(self.macros, macro_dicts):
            mc.name = md["name"]
            mc.text = md["text"]
            mc.hex = md["hex"]
            # print(md)

    def write(self):
        with open(self.filename, "w") as outfile:
            json.dump(self.to_json(), outfile, indent=4)

    def load(self):
        if not os.path.exists(self.filename):
            self.write()

        with open(self.filename, "r") as infile:
            jsd = json.load(infile)

        self.from_json(jsd)


class HexMode(enum.Enum):
    Length = 1
    SynchAfter = 2
    SynchBefore = 3


class HexFormater:
    def __init__(self) -> None:
        # self.index = 0
        # self.max = 12
        self.end = "<br>"
        self.sync_byte = "0xff"
        self.mode = HexMode.Length
        self.set_mode(MpTerm.Ascii)
        self.set_columns(12)
        self.clear()

    def set_mode(self, mode: MpTerm) -> None:
        self.mode = mode
        self.index = 1

    def clear(self) -> None:
        self.index = 1
        # self.chars = []

    def append(self, chr: str) -> None:
        self.chars.append(chr)

    def set_columns(self, cols):
        self.max = cols

    def get_char(self, byte) -> str:
        if self.mode == MpTerm.Hex:
            return f"{chd:02x}"

        if self.mode == MpTerm.AsciiHex:
            return f"{chd:02x}"

    def _format_ascii_hex(self, data: bytearray) -> str:
        s = "<pre>"
        for i in range(0, data.count()):
            if self.index >= self.max:
                s += "<br>"  # self.end
                self.clear()
            byte = data.at(i)
            ch = int.from_bytes(byte, "big")
            cs = hex2str(ch)
            if len(cs) == 1:
                cs = f'"{cs}"'
            s += f"""<b>{ch:02x}</b> {cs:3} """
            self.index += 1
        s += "</pre>"
        return s

    def _format_hex(self, data: bytearray) -> str:
        for i in range(0, data.count()):
            ch = data.at(i)
            chd = int.from_bytes(ch, "big")
            if chd == 0xFF:
                print(f"Synch line {self.index}")
                self.clear()
                self.append(f"<br>{chd:02x} ")
                continue

            if self.index == (self.max - 1):
                # if len(self.chars) == (self.max):
                self.clear()
                self.append(f"{chd:02x}<br>")
                print("Long line")
                continue

            # s += f"{chd:02x} "
            # self.index += 1

            # self.append_char(f"{chd:02x} ")

            # x = f"{chd:02x} "
            self.append(f"{chd:02x} ")
            self.index += 1
        return "".join(self.chars)

    def update(self, data: bytearray) -> str:
        self.chars = []
        print(f"Data: {len(data)}")
        if self.mode == MpTerm.Hex:
            return self._format_hex(data)

        if self.mode == MpTerm.AsciiHex:
            return self._format_ascii_hex(data)

        return ""


class StyleS:
    normal = """
    color:Black;
    """
    error = """
    color:Red;
    """
    win = "border:0"


class QNumberEdit(QLineEdit):
    def __init__(self, parent=None):
        super().__init__()
        self.setText("36")
        self.textChanged.connect(self.changed)
        self.setMaximumWidth(80)
        self.setStyle

    def changed(self, a0: str) -> None:
        if self.text().strip().isnumeric():
            self.setStyleSheet(StyleS.normal)
        else:
            self.setStyleSheet(StyleS.error)

    def get_value(self) -> int:
        if self.text().strip().isnumeric():
            return int(self.text().strip())

        return 10


class QMacroButton(QWidget):
    def __init__(self, macro: Macro, parent=None):
        super().__init__()
        self.macro = macro
        self.layout = QHBoxLayout()
        # self.layout.setContentsMargins(2, 2, 2, 2)
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.layout.setSpacing(2)
        self.setLayout(self.layout)

        self.setSizePolicy(QSizePolicy.MinimumExpanding, QSizePolicy.Minimum)

        self.macroButton = QPushButton(macro.name)
        self.macroButton.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)
        self.layout.addWidget(self.macroButton)
        self.repeatButton = QPushButton("R")
        # self.repeatButton.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)
        self.repeatButton.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)

        self.layout.addWidget(self.repeatButton)


class MacroEditWidget(QWidget):
    def __init__(self, macro: Macro, parent=None):
        super().__init__()
        self.macro = macro
        self.layout = QHBoxLayout()
        self.layout.setContentsMargins(2, 2, 2, 2)
        # self.layout.setSpacing(2)
        self.setLayout(self.layout)

        self.name = QLabel(macro.name)
        self.macro_edit = QLineEdit(macro.text)
        self.macro_edit.textChanged.connect(self.macroChanged)
        self.hexModeCb = QCheckBox("Hex")
        self.hexModeCb.stateChanged.connect(self.macroChanged)
        self.repeatCb = QCheckBox("Repeat")

        self.intervallEdit = QLineEdit(str(macro.intervallEdit))
        self.intervallEdit.textChanged.connect(self.intervallChanged)
        self.intervallEdit.setMaximumWidth(40)
        # self.setMaxLength(4)
        # self.setSizePolicy(5)

        self.layout.addWidget(self.name)
        self.layout.addWidget(self.macro_edit)
        self.layout.addWidget(self.hexModeCb)
        # self.layout.addWidget(self.repeatCb)
        # self.layout.addWidget(self.intervallEdit)

    def intervallChanged(self, a0: str) -> None:
        if self.intervallEdit.text().isnumeric():
            self.intervallEdit.setStyleSheet(StyleS.normal)
        else:
            self.intervallEdit.setStyleSheet(StyleS.error)

    def update(self) -> None:
        self.macro_edit.setText(self.macro.text)
        self.hexModeCb.setChecked(self.macro.hex)

    def hex_mode(self) -> bool:
        return self.hexModeCb.isChecked()

    def hex_mode_changed(self, a0: str) -> None:
        self.macroChanged()

    def macroChanged(self) -> None:
        if self.hex_mode() is True:
            if Macro.is_hex_string(self.macro_edit.text()) is True:
                self.macro_edit.setStyleSheet(StyleS.normal)
            else:
                self.macro_edit.setStyleSheet(StyleS.error)
        else:
            self.macro_edit.setStyleSheet(StyleS.normal)

    def accept(self) -> None:
        self.macro.text = self.macro_edit.text()
        self.macro.hex = self.hexModeCb.isChecked()


class MacroDialog(QDialog):
    def __init__(self, macros) -> None:
        super().__init__()
        self.setWindowTitle("Userdefined Macros")
        self.setMinimumWidth(600)
        self.macros = macros
        self.main_layout = QVBoxLayout()
        self.main_layout.setSpacing(2)
        self.setLayout(self.main_layout)

        self.macro_edits = []
        for macro in self.macros:
            mew = MacroEditWidget(macro)
            self.main_layout.addWidget(mew)
            self.macro_edits.append(mew)

        self.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.buttonBox.accepted.connect(self.accept)
        self.buttonBox.rejected.connect(self.reject)
        self.main_layout.addWidget(self.buttonBox)

    def exec(self, macros) -> int:
        for macro_edit in self.macro_edits:
            macro_edit.update()

        return super().exec()

    def accept(self):
        for macro_edit in self.macro_edits:
            macro_edit.accept()

        self.close()


class MainForm(QMainWindow):
    # Handle windows close event
    def closeEvent(self, a0: QCloseEvent) -> None:
        self.save_settings()
        return super().closeEvent(a0)

    def add_label_combobox(self, labelText) -> QComboBox:
        label = QLabel(self.centralwidget)
        label.setText(f"<b>{labelText}:</b>")
        label.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.portLayout.addWidget(label)
        comboBox = QComboBox(self.centralwidget)
        comboBox.setEditable(False)
        comboBox.setCurrentText("")
        self.portLayout.addWidget(comboBox)
        return comboBox

    def __init__(self, args, parent=None) -> None:
        super(MainForm, self).__init__(parent)

        self.prof = mpProfile(filename=App.SETTINGS_FILE)
        self.prof.load()

        self.centralwidget = QWidget(self)

        self.verticalLayout = QVBoxLayout(self.centralwidget)
        self.verticalLayout.setContentsMargins(2, 2, 2, 2)
        self.verticalLayout.setSpacing(2)

        self.resize(self.prof.win_x, self.prof.win_y)
        # self.resize(850, 500)
        self.setWindowIcon(QIcon(App.ICON))
        self.setCentralWidget(self.centralwidget)

        # Serial port settings above terminal widget
        self.portLayout = QHBoxLayout()
        self.portLayout.setSpacing(5)
        # self.portLayout.addSpacing(90)
        self.portLayout.addStretch()

        self.cbPort = self.add_label_combobox("Port")

        self.cbBitrate = self.add_label_combobox("Bitrate")
        self.cbBitrate.addItem("300", 300)
        self.cbBitrate.addItem("600", 600)
        self.cbBitrate.addItem("1200", 1200)
        self.cbBitrate.addItem("2400", 2400)
        self.cbBitrate.addItem("4800", 4800)
        self.cbBitrate.addItem("9600", 9600)
        self.cbBitrate.addItem("19200", 19200)
        self.cbBitrate.addItem("28400", 28400)
        self.cbBitrate.addItem("57600", 57600)
        self.cbBitrate.addItem("115200", 115200)
        self.cbBitrate.setCurrentIndex(5)
        self.cbBitrate.activated.connect(self.set_sp)

        self.cbBits = self.add_label_combobox("Bits")
        self.cbBits.addItem("5", QSerialPort.Data5)
        self.cbBits.addItem("6", QSerialPort.Data6)
        self.cbBits.addItem("7", QSerialPort.Data7)
        self.cbBits.addItem("8", QSerialPort.Data8)
        self.cbBits.setCurrentIndex(3)
        self.cbBits.activated.connect(self.set_sp)

        self.cbStopBits = self.add_label_combobox("StopBit")
        self.cbStopBits.addItem("1", QSerialPort.OneStop)
        self.cbStopBits.addItem("1.5", QSerialPort.OneAndHalfStop)
        self.cbStopBits.addItem("2", QSerialPort.TwoStop)
        self.cbStopBits.setCurrentIndex(0)
        self.cbStopBits.activated.connect(self.set_sp)

        self.cbParity = self.add_label_combobox("Parity")
        self.cbParity.addItem("None", QSerialPort.NoParity)
        self.cbParity.addItem("Odd", QSerialPort.OddParity)
        self.cbParity.addItem("Even", QSerialPort.EvenParity)
        self.cbParity.setCurrentIndex(0)
        self.cbParity.activated.connect(self.set_sp)

        self.cbFlowControl = self.add_label_combobox("HwFlow")
        self.cbFlowControl.addItem("None", QSerialPort.NoFlowControl)
        self.cbFlowControl.addItem("Hardware", QSerialPort.HardwareControl)
        self.cbFlowControl.addItem("Software", QSerialPort.SoftwareControl)
        self.cbFlowControl.setCurrentIndex(0)
        self.cbFlowControl.activated.connect(self.set_sp)
        # self.portLayout.addSpacing(20)
        self.portLayout.addStretch()

        # "Buttons" layout, to the left
        self.buttonLayout = QVBoxLayout()
        self.buttonLayout.addSpacing(10)

        self.pbOpen = QPushButton("Open", self.centralwidget)
        self.pbOpen.setFixedHeight(50)
        self.pbOpen.pressed.connect(self.openPort)
        self.buttonLayout.addWidget(self.pbOpen)

        self.cbMode = QComboBox(self.centralwidget)
        self.cbMode.addItem(Mode.Normal.name, Mode.Normal)
        self.cbMode.addItem(Mode.Echo.name, Mode.Echo)
        self.buttonLayout.addWidget(self.cbMode)

        self.cbDisplay = QComboBox(self.centralwidget)
        self.cbDisplay.addItem("Ascii", MpTerm.Ascii)
        self.cbDisplay.addItem("Hex", MpTerm.Hex)
        self.cbDisplay.addItem("Hex + Ascii", MpTerm.AsciiHex)
        self.cbDisplay.currentIndexChanged.connect(self.mode_change)
        self.cbDisplay.activated.connect(self.set_sp)
        self.buttonLayout.addWidget(self.cbDisplay)

        self.cbNewlineMode = QComboBox(self.centralwidget)
        self.cbNewlineMode.addItem("LF", "\n")
        self.cbNewlineMode.addItem("CR", "\r")
        self.cbNewlineMode.addItem("CRLF", "\r\n")
        self.buttonLayout.addWidget(self.cbNewlineMode)

        self.nrEdit = QNumberEdit(self.centralWidget)
        self.buttonLayout.addWidget(self.nrEdit)

        # self.pbTermSet = QPushButton("Find\nTerm", self.centralwidget)
        # self.pbTermSet.pressed.connect(self.openPort)
        # self.buttonLayout.addWidget(self.pbTermSet)

        self.buttonLayout.addStretch()

        # self.cbNewline = QComboBox(self.centralwidget)
        # self.cbNewline.addItem("nl", 0)
        # self.cbNewline.addItem("cr", 1)
        # self.cbNewline.addItem("cr+nl", 2)

        # self.dtrLabel = QLabel("\u26D4 DTR")
        # self.rtsLabel = QLabel("\u26D4 RTS")

        # self.cbRTS = QCheckBox(self.centralwidget)
        # self.cbRTS.setText("RTS")
        # self.cbRTS.clicked.connect(self.handle_rts)

        # self.cbDTR = QCheckBox(self.centralwidget)
        # self.cbDTR.setText("DTR")
        # self.cbDTR.setCheckable(True)
        # self.cbDTR.setChecked(False)
        # self.cbDTR.setTristate(False)
        # self.cbDTR.clicked.connect(self.handle_dtr)

        self.pbProgram = QPushButton("Program", self.centralwidget)
        self.pbProgram.pressed.connect(self.run_ext_program)
        self.buttonLayout.addWidget(self.pbProgram)

        self.pbSuspend = QPushButton("Suspend", self.centralwidget)
        self.pbSuspend.pressed.connect(self.suspend)
        self.buttonLayout.addWidget(self.pbSuspend)

        # self.leSyncString = QLineEdit(self.centralwidget)
        # self.buttonLayout.addWidget(self.leSyncString)

        # self.cbProfiles = QComboBox(self.centralwidget)
        # self.cbProfiles.setObjectName("cbProfiles")
        # self.cbProfiles.addItem("Default", 0)
        # self.cbProfiles.addItem("115200", 2)
        # self.cbProfiles.addItem("New...", 3)
        # self.cbProfiles.hide()
        # self.buttonLayout.addWidget(self.cbNewline)
        # self.buttonLayout.addWidget(self.cbRTS)
        # self.buttonLayout.addWidget(self.cbDTR)
        # self.buttonLayout.addWidget(self.dtrLabel)
        # self.buttonLayout.addWidget(self.rtsLabel)

        self.serialPort = SerialPort()
        self.serialPort.setReadBufferSize(256)
        self.serialPort.readyRead.connect(self.read)
        self.terminal = QTerminalWidget(self.centralwidget)
        # self.terminal = QTerminalWidget(self.centralwidget, serialPort=self.serialPort)
        self.terminal.setMaxLines(App.MAX_LINES)

        # Layouts
        self.rightVLayout = QVBoxLayout()
        self.rightVLayout.addWidget(self.terminal)

        self.main_layout = QHBoxLayout()
        self.main_layout.addLayout(self.buttonLayout)
        self.main_layout.addLayout(self.rightVLayout)

        self.verticalLayout.addLayout(self.portLayout)
        self.verticalLayout.addLayout(self.main_layout)

        # Macro layout (to the right)
        self.macroLayout = QVBoxLayout()
        self.macroLayout.setContentsMargins(2, 2, 2, 2)
        self.macroLayout.setSpacing(2)
        self.macroLayout.addSpacing(20)

        for macro in self.prof.macros:
            macro_button = QPushButton(
                macro.name,
                self.centralwidget,
                pressed=lambda m=macro: self.serialPort.send(m.data()),
            )
            self.macroLayout.addWidget(macro_button)

            # macro_button = QMacroButton(macro=macro)
            # self.macroLayout.addWidget(macro_button)

        self.macro_dialog = MacroDialog(self.prof.macros)
        self.macro_set = QPushButton("Edit macro's", self.centralwidget)
        self.macro_set.pressed.connect(self.edit_macro_dialog)

        self.macroLayout.addSpacing(20)
        self.macroLayout.addWidget(self.macro_set)
        self.macroLayout.addStretch()

        self.pbPause = QPushButton("Pause", self.centralwidget)
        self.pbPause.pressed.connect(self.pause)
        self.macroLayout.addWidget(self.pbPause)

        self.main_layout.addLayout(self.macroLayout)

        # Status bar
        self.statusbar = QStatusBar(self)
        self.statusbar.setLayoutDirection(Qt.LeftToRight)
        self.statusbar.setStyleSheet(StyleS.normal)
        self.setStatusBar(self.statusbar)

        # Status bar elements
        self.stateLabel = QLabel("")
        self.statusbar.addPermanentWidget(self.stateLabel, stretch=0)
        self.rxLabel = QLabel("")
        self.statusbar.addPermanentWidget(self.rxLabel, stretch=0)
        self.txLabel = QLabel("")
        self.statusbar.addPermanentWidget(self.txLabel, stretch=0)
        self.dimensionsLabel = QLabel("")
        # self.dimensionsLabel.setToolTip("Terminal size")
        self.statusbar.addPermanentWidget(self.dimensionsLabel, stretch=0)
        # self.yyy = QComboBox(self.centralwidget)
        # self.yyy.addItem("80x24", Mode.Normal)
        # self.yyy.addItem("132x24", Mode.Normal)
        # self.statusbar.addPermanentWidget(self.yyy)

        # Menu bar
        self.menubar = QMenuBar(self)
        self.setMenuBar(self.menubar)

        # File menu
        self.menuFile = QMenu(self.menubar, title="&File")
        self.menubar.addAction(self.menuFile.menuAction())
        self.actionNew = QAction("New", self, triggered=self.new_terminal)
        self.menuFile.addAction(self.actionNew)
        self.actionExit = QAction("Quit", self, triggered=self.exit_program)
        self.actionExit.setToolTip("Quit")
        self.actionExit.setShortcutContext(Qt.WidgetShortcut)
        self.menuFile.addAction(self.actionExit)

        # self.actionEcho = QAction(
        #     "Echo", self, triggered=None, checkable=True
        # )
        # self.menuSettings.addAction(self.actionEcho)

        # Settings menu
        self.menuSettings = QMenu(self.menubar, title="Settings")
        self.menubar.addAction(self.menuSettings.menuAction())
        self.actionSetProgram = QAction(
            "Ext. Program", self, triggered=self.set_ext_program
        )
        self.menuSettings.addAction(self.actionSetProgram)
        self.actionSetTimeout = QAction(
            "Suspend timeout", self, triggered=self.set_suspend_timeout
        )
        self.menuSettings.addAction(self.actionSetTimeout)

        # Action menu
        self.menuAction = QMenu(self.menubar, title="&Action")
        self.menubar.addAction(self.menuAction.menuAction())
        self.actionClear = QAction(self, text="Clear")
        self.actionClear.triggered.connect(self.terminal_clear)
        self.menuAction.addAction(self.actionClear)

        self.actionReset_port = QAction(self, text="Reset port")
        self.actionPortInfo = QAction(self, text="Port info", triggered=self.port_info)
        self.menuAction.addAction(self.actionPortInfo)

        # Send menu
        self.menuSend = QMenu(self.menubar, title="Send")
        self.menubar.addAction(self.menuSend.menuAction())
        self.add_action(
            "Break [0x00]", self.menuSend, lambda: self.send_string(Ascii.NULL)
        )
        self.add_action(
            "ETX [0x03] (Ctrl-C)", self.menuSend, lambda: self.send_string(Ascii.ETX)
        )
        self.add_action(
            "EOT [0x04] (Ctrl-D)", self.menuSend, lambda: self.send_string(Ascii.ETX)
        )
        self.add_action(
            "Tab [0x09]", self.menuSend, lambda: self.send_string(Ascii.TAB)
        )
        self.add_action("LF [0x0a]", self.menuSend, lambda: self.send_string(Ascii.NL))
        self.add_action("CR [0x0d]", self.menuSend, lambda: self.send_string(Ascii.CR))

        self.testMenu = self.menuSend.addMenu("Tests")

        sendTestAction = QAction("Escape test", self)
        sendTestAction.triggered.connect(
            lambda: self.send_string(escape_attribute_test)
        )
        self.testMenu.addAction(sendTestAction)

        sendFlagAction = QAction("Flag SE", self)
        sendFlagAction.triggered.connect(lambda: self.send_string(flag))
        self.testMenu.addAction(sendFlagAction)

        colorAction = QAction("Color test", self)
        colorAction.triggered.connect(lambda: self.send_string(color_256_test()))
        self.testMenu.addAction(colorAction)

        self.colorMenu = self.menuSend.addMenu("Colors")
        self.add_action("Red", self.colorMenu, lambda: self.send_string(Escape.RED))
        self.add_action("Green", self.colorMenu, lambda: self.send_string(Escape.GREEN))
        self.add_action(
            "Yellow", self.colorMenu, lambda: self.send_string(Escape.YELLOW)
        )
        self.add_action("Blue", self.colorMenu, lambda: self.send_string(Escape.BLUE))
        self.add_action(
            "Magenta", self.colorMenu, lambda: self.send_string(Escape.MAGENTA)
        )
        self.add_action("Cyan", self.colorMenu, lambda: self.send_string(Escape.CYAN))
        self.add_action("White", self.colorMenu, lambda: self.send_string(Escape.WHITE))

        self.add_action(
            "Bg Red", self.colorMenu, lambda: self.send_string(Escape.BG_RED)
        )
        self.add_action(
            "Bg Green", self.colorMenu, lambda: self.send_string(Escape.BG_GREEN)
        )
        self.add_action(
            "Bg Yellow", self.colorMenu, lambda: self.send_string(Escape.BG_YELLOW)
        )
        self.add_action(
            "Bg Blue", self.colorMenu, lambda: self.send_string(Escape.BG_BLUE)
        )
        self.add_action(
            "Bg Magenta", self.colorMenu, lambda: self.send_string(Escape.BG_MAGENTA)
        )
        self.add_action(
            "Bg Cyan", self.colorMenu, lambda: self.send_string(Escape.BG_CYAN)
        )
        self.add_action(
            "Bg White", self.colorMenu, lambda: self.send_string(Escape.BG_WHITE)
        )

        self.attrMenu = self.menuSend.addMenu("Attributes")
        self.add_action("Reset", self.attrMenu, lambda: self.send_string(Escape.RESET))
        self.add_action("Bold", self.attrMenu, lambda: self.send_string(Escape.BOLD))
        self.add_action(
            "Italic", self.attrMenu, lambda: self.send_string(Escape.ITALIC)
        )
        self.add_action("Dim", self.attrMenu, lambda: self.send_string(Escape.DIM))
        self.add_action(
            "Reverse", self.attrMenu, lambda: self.send_string(Escape.REVERSE)
        )
        self.add_action(
            "Underline", self.attrMenu, lambda: self.send_string(Escape.UNDERLINE)
        )
        self.add_action(
            "Crossed", self.attrMenu, lambda: self.send_string(Escape.CROSSED)
        )

        self.attrMenu = self.menuSend.addMenu("Cursor")
        self.add_action("Up", self.attrMenu, lambda: self.send_string(Escape.UP))
        self.add_action("Down", self.attrMenu, lambda: self.send_string(Escape.DOWN))
        self.add_action(
            "Forward", self.attrMenu, lambda: self.send_string(Escape.FORWARD)
        )
        self.add_action(
            "Backward",
            self.attrMenu,
            lambda: self.send_string(Escape.BACK),
        )

        # Help menu
        self.menuHelp = QMenu(self.menubar, title="&Help")
        self.menubar.addAction(self.menuHelp.menuAction())
        self.actionAbout = QAction(self, text="About")
        self.actionAbout.triggered.connect(
            lambda: AboutDialog.about(App.NAME, about_html)
        )
        self.menuHelp.addAction(self.actionAbout)

        # Scan for serialports
        self.update_ports()
        self.formater = HexFormater()

        self.load_settings()
        self.mode_change()

        # If commandline argument use it instead of saved parameter
        if args.ext_program != "":
            self.prof.ext_program = args.ext_program

        # Configure signal handler
        signal.signal(signal.SIGUSR1, self.signal_usr1)
        signal.signal(signal.SIGUSR2, self.signal_usr2)

        # Timers
        self.timer = QTimer()
        self.timer.setInterval(1000)
        self.timer.timeout.connect(self.timer_event)
        self.timer.start()

        self.timer_5 = QTimer()
        self.timer_5.setInterval(200)
        self.timer_5.timeout.connect(self.timer_5_timeout)
        self.timer_5.start()

        self.ts = TerminalState()

        self.process = QProcess()
        self.process.readyReadStandardOutput.connect(self.program_stdout_available)
        self.process.readyReadStandardError.connect(self.program_stderr_available)
        self.process.finished.connect(self.program_finished)

        self.isPaused = False

        self.terminal.installEventFilter(self)
        self.terminal.append_html(f"""MpTerm Ver: <b>{App.VERSION}</b><br><br>""")

        self.update_ui()
        self.init_port()

    def edit_macro_dialog(self) -> None:
        # self.macro_dialog.exec(self.macro_list)
        self.macro_dialog.exec(self.prof.macros)

    def set_suspend_timeout(self) -> None:
        dlg = QInputDialog()
        val, name = dlg.getInt(
            self, "Suspend timeout", "Timeout (s)", value=self.prof.suspend_timeout
        )
        if name is True:
            self.prof.suspend_timeout = val

    def set_ext_program(self) -> None:
        dlg = QInputDialog()
        # val, ok = dlg.getText(self, "External program", "Commandline", text=self.prof.ext_program)
        dlg.setInputMode(QInputDialog.TextInput)
        dlg.setWindowTitle("External program")
        dlg.setLabelText("Commandline:")
        dlg.setTextValue(self.prof.ext_program)
        dlg.resize(700, 200)
        ok = dlg.exec_()
        # if ok is True:
        self.prof.ext_program = dlg.textValue()

        # val = dlg.getText(self, "External program", "Commandline", text=self.prof.ext_program)

    def keyPressEvent(self, e: QKeyEvent) -> None:
        super().keyPressEvent(e)
        # logging.debug(f"  {e.key():name}  {get_description(e)}")
        self.serialPort.send_string(get_key(e))

    def eventFilter(self, obj: QObject, event: QEvent) -> bool:
        key2key = {
            Qt.Key_Tab: Ascii.TAB,
            Qt.Key_Left: Escape.BACK,
            Qt.Key_Right: Escape.FORWARD,
            Qt.Key_Up: Escape.UP,
            Qt.Key_Down: Escape.DOWN,
            Qt.Key_Delete: Escape.KEY_DELETE,
            Qt.Key_Space: " ",
            Qt.Key_Enter: "",
            Qt.Key_Return: "",
        }
        # logging.debug(f"Event: {event}")
        # print(event.type())
        if event.type() == QEvent.KeyPress:
            keyEvent = QKeyEvent(event)
            if keyEvent.key() in [Qt.Key_Enter, Qt.Key_Return]:
                self.serialPort.send_string(self.cbNewlineMode.currentData())
                return True

            if keyEvent.key() in key2key:
                logging.debug(f"Key:{keyEvent.key()}")
                self.serialPort.send_string(key2key[keyEvent.key()])
                return True
            else:
                return False
        return False

    def send_macro(self, macro: Macro) -> None:
        self.serialPort.send(macro.data())

    # def key(self, e: QKeyEvent) -> None:
    #     # logging.debug(f"  {e.key():name}  {get_description(e)}")
    #     # self.sp.send_string(get_key(e))
    #     print("Keypressed")

    def add_action(self, name, menu, function) -> QAction:
        action = QAction(name, self)
        menu.addAction(action)
        action.triggered.connect(function)
        return action

    def pause(self) -> None:
        if self.isPaused is True:
            self.isPaused = False
        else:
            self.isPaused = True

    def suspend(self) -> None:
        logging.debug(f"Suspending port for {self.prof.suspend_timeout} s.")
        self.serialPort.set_state(
            State.SUSPENDED, timeout=self.prof.suspend_timeout * 1000
        )
        self.update_ui()

    def program_stdout_available(self) -> None:
        logging.debug("Program received stdout data")
        data = self.process.readAllStandardOutput()
        data_str = str(data, "utf-8")
        self.terminal.append_terminal_text(data_str)
        self.terminal.scroll_down()
        self.update_ui()

    def program_stderr_available(self) -> None:
        logging.debug("Program received stderr data")
        data = self.process.readAllStandardError()
        data_str = str(data, "utf-8")
        self.terminal.append_terminal_text(data_str)
        self.terminal.scroll_down()
        self.update_ui()

    def program_finished(self) -> None:
        logging.debug("External program finnished executing")
        self.terminal.append_html("<br>")
        if self.serialPort.state == State.SUSPENDED:
            self.serialPort.set_state(State.RECONNECTING)
        self.update_ui()

    def run_ext_program(self) -> None:
        if self.serialPort.state == State.SUSPENDED:
            return

        if self.serialPort.state == State.CONNECTED:
            self.serialPort.set_state(State.SUSPENDED, timeout=-1)

        self.terminal.append_html("<br>")
        ext_prog = self.prof.ext_program.replace(
            "__PORT__", f"/dev/{self.serialPort.portName()}"
        )
        self.process.start(ext_prog)
        logging.debug(
            f"Runing external run_ext_program: {ext_prog}  {self.process.processId()}"
        )
        self.update_ui()
        self.terminal.scroll_down()

    def signal_usr1(self, signum, frame) -> None:
        logging.debug("USR1 signal received")
        self.suspend()

    def signal_usr2(self, signum, frame) -> None:
        logging.debug("USR2 signal received")
        self.run_ext_program()

    def timer_5_timeout(self) -> None:
        self.update_ui()

    def port_handler(self) -> None:
        portNames = [name.portName() for name in QSerialPortInfo.availablePorts()]

        # Check if current port is still connecter (USB to serial adapters), if not close port
        if self.serialPort.isOpen():
            if self.serialPort.portName() not in portNames:
                self.serialPort.close()
                self.message_error(
                    f"Port {self.serialPort.portName()} no longer available."
                )

        # Update list of serialports in combobox
        for name in range(self.cbPort.count()):
            if self.cbPort.itemText(name) not in portNames:
                self.cbPort.removeItem(name)
            else:
                portNames.remove(self.cbPort.itemText(name))

        for name in portNames:
            self.cbPort.addItem(name)

    def timer_event(self) -> None:
        self.port_handler()

    def update_ui(self) -> None:
        if self.serialPort.state == State.DISCONNECTED:
            self.setWindowTitle("MpTerm")
            self.pbOpen.setText("Open")
            self.cbPort.setEnabled(True)
        else:
            self.setWindowTitle(
                f"MpTerm  /dev/{self.cbPort.currentText()} {self.cbBitrate.currentText()}"
            )
            self.pbOpen.setText("Close")
            self.cbPort.setEnabled(False)

        self.rxLabel.setText(
            f'<span style="color:Black">RX:</span> <span style="color:Purple">{self.serialPort.rxCnt:06d}</span> '
        )
        self.txLabel.setText(
            f'<span style="color:Black">TX:</span> <span style="color:Purple">{self.serialPort.txCnt:06d}</span> '
        )
        self.dimensionsLabel.setText(
            f'<span style="color:Black">{self.terminal.ts.max.column:3d}x{self.terminal.ts.max.row:2d}</span> '
        )

        states = {
            State.DISCONNECTED: f"""<span style="color:Black">Disconected</span>""",
            State.CONNECTED: f"""<span style="color:Green">Connected  </span>""",
            State.SUSPENDED: f"""<span style="color:Red">Suspended {self.serialPort.suspend_timer.remainingTime()/1000:.0f}</span>""",
            State.RECONNECTING: f"""<span style="color:Magenta">Reconnecting {self.serialPort.cntReconnect}</span>""",
        }
        self.stateLabel.setText(f"{states[self.serialPort.state]}")

        if self.isPaused is True:
            self.pbPause.setText("Paused")
        else:
            self.pbPause.setText("Pause")

        self.formater.set_columns(self.nrEdit.get_value())

        # if self.serialPort.isDataTerminalReady():
        #     self.dtrLabel.setText("\u26AA  DTR")
        # else:
        #     self.dtrLabel.setText("\u26AB  DTR")

        # if self.serialPort.isRequestToSend():
        #     self.rtsLabel.setText("\u26AA  RTS")
        # else:
        #     self.rtsLabel.setText("\u26AB  RTS")

        # logging.debug(f"DTR: {self.sp.serial_port.isDataTerminalReady()}  RTS: {self.sp.serial_port.isRequestToSend()}")

    def update_ports(self) -> None:
        ports = QSerialPortInfo.availablePorts()
        for port in ports:
            self.cbPort.addItem(port.portName())

    def handle_dtr(self) -> None:
        # self.ui.cbDTR.clicked.connect(self.handle_dtr)
        logging.debug("DTR")
        if self.cbDTR.isChecked():
            self.cbDTR.setChecked(True)
            self.serialPort.setDataTerminalReady(True)
        else:
            self.cbDTR.setChecked(False)
            self.serialPort.setDataTerminalReady(False)

    def handle_rts(self) -> None:
        logging.debug("RTS")
        if self.cbRTS.isChecked():
            self.cbRTS.setChecked(True)
            self.serialPort.setRequestToSend(True)
        else:
            self.cbRTS.setChecked(False)
            self.serialPort.setRequestToSend(False)

    def sync_changed(self) -> None:
        try:
            self.sync = int(self.leSyncString.text(), 16)

            if self.sync > 255 or self.sync < 0:
                self.sync = -1
                self.lSync.setText('<font color="Red">Sync string')
            else:
                self.lSync.setText('<font color="Black">Sync string')

        except ValueError:
            self.sync = -1
            text = self.leSyncString.text()
            #            print(len(text), 'Text: '+text)
            if len(text) > 0:
                self.lSync.setText('<font color="Red">Sync string')
            else:
                self.lSync.setText('<font color="Black">Sync string')
        return

    def terminal_clear(self) -> None:
        self.terminal.clear()
        self.formater.clear()
        self.serialPort.clear_counters()
        self.update()

    def _message(self, name) -> None:
        self.statusbar.showMessage(name, 4000)
        self.statusbar.show

    # Show message in status bar
    def message(self, name) -> None:
        self.statusbar.setStyleSheet(StyleS.normal)
        self._message(name)
        logging.debug(name)

    # Show error message in status bar
    def message_error(self, name) -> None:
        self.statusbar.setStyleSheet(StyleS.error)
        self._message(name)
        logging.error(name)

    def mode_change(self) -> None:
        self.terminal.clear()
        self.formater.set_mode(self.cbDisplay.currentData())
        logging.debug(f"Setting display mode {self.cbDisplay.currentData()}")

    def append_html(self, str) -> None:
        self.terminal.moveCursor(QTextCursor.End)
        self.terminal.append_html(str)

    def read(self) -> None:
        data = self.serialPort.read()
        try:
            data_str = str(data, "utf-8")
        except UnicodeDecodeError:
            data_str = ""
            pass

        db = Escape.to_str(data_str)

        logging.debug(f'Data received: {len(data)} "{db}"')

        if self.isPaused:
            self.update_ui()
            return

        DisplayMode = self.cbDisplay.currentData()

        if DisplayMode == MpTerm.Ascii:  # Standard ascii display mode
            self.terminal.append_terminal_text(data_str)

        if DisplayMode != MpTerm.Ascii:  # Hexadecimal display mode
            # self.terminal.append_terminal_text(self.formater.update(data))
            self.terminal.append_html(self.formater.update(data))

        self.terminal.scroll_down()
        self.update_ui()

        if self.cbMode.currentData() == Mode.Echo:
            self.serialPort.send(data)

    def send(self, data: bytearray) -> None:
        if self.serialPort.isOpen():
            # res = self.serialPort.serial_port.write(data)
            res = self.serialPort.write(data)
            if res > 0:
                self.serialPort.txCnt += res
            else:
                logging.error("Could not write data.")
            self.update_ui()

    def send_string(self, data: str) -> None:
        self.send(bytearray(data, "utf-8"))

    def openPort(self) -> None:
        if self.serialPort.isOpen():
            self.serialPort.close()
            self.update_ui()
            return

        self.serialPort.clear()
        self.init_port()
        res = self.serialPort.open()
        if res:
            self.message(
                f"Opening port: /dev/{self.serialPort.portName()} {self.serialPort.baudRate()}"
            )
        else:
            self.message_error(
                f"Failed to open port /dev/{self.serialPort.portName()}. {self.serialPort.error()}"
            )

        self.update_ui()

    def init_port(self) -> None:
        self.set_port()
        self.set_sp()

    def set_port(self) -> None:
        self.serialPort.setPortName(f"/dev/{self.cbPort.currentText()}")

    def set_sp(self) -> None:
        br = self.cbBitrate.currentData()
        self.serialPort.setBaudRate(self.cbBitrate.currentData())
        self.serialPort.setStopBits(self.cbStopBits.currentData())
        self.serialPort.setDataBits(self.cbBits.currentData())
        self.serialPort.setParity(self.cbParity.currentData())
        self.serialPort.setFlowControl(self.cbFlowControl.currentData())
        logging.debug(self.cbBitrate.currentData())

    def save_settings(self) -> None:
        self.prof.port = self.cbPort.currentText()
        self.prof.bitrate = self.cbBitrate.currentText()
        self.prof.databits = self.cbBits.currentText()
        self.prof.stopbits = self.cbStopBits.currentText()
        self.prof.parity = self.cbParity.currentText()
        self.prof.flowcontrol = self.cbFlowControl.currentText()
        self.prof.mode = self.cbDisplay.currentData().name
        self.prof.newline = self.cbNewlineMode.currentText()
        self.prof.win_x = self.width()
        self.prof.win_y = self.height()
        self.prof.write()

    def load_cb_setting(self, cb, setting) -> None:
        idx = cb.findText(setting)
        if idx != -1:
            cb.setCurrentIndex(idx)

    def load_settings(self) -> None:
        self.load_cb_setting(self.cbBitrate, self.prof.bitrate)
        self.load_cb_setting(self.cbBitrate, self.prof.bitrate)
        self.load_cb_setting(self.cbPort, self.prof.port)
        self.load_cb_setting(self.cbStopBits, self.prof.stopbits)
        self.load_cb_setting(self.cbBits, self.prof.databits)
        self.load_cb_setting(self.cbParity, self.prof.parity)
        self.load_cb_setting(self.cbFlowControl, self.prof.flowcontrol)
        self.load_cb_setting(self.cbNewlineMode, self.prof.newline)

        idx = self.cbDisplay.findData(MpTerm(self.prof.mode))
        self.cbDisplay.setCurrentIndex(idx)

    def exit_program(self, e) -> None:
        self.serialPort.close()
        self.close()

    def ss(self, str):
        print(len(str))
        nstr = str
        for i in range(1, 16 - len(str)):
            nstr += "&nbsp;"
        return nstr

    def append_info(self, desc: str, data: str) -> None:
        self.append_html(f"<b>{self.ss(desc)}</b><code><font color='Green'>{data}<br>")

    def port_info(self) -> None:
        self.append_html('<hr width="50%" color="Green" size="50px"/>')
        self.append_html("asdfasdfasdf")
        self.append_html("<br>")
        self.append_html("<hr>")
        ports = QSerialPortInfo.availablePorts()
        for port in ports:
            self.append_info("Port:", port.portName())
            self.append_info("Location:", port.systemLocation())
            self.append_info("Vendor id:", str(port.vendorIdentifier()))
            self.append_info("Product id:", str(port.productIdentifier()))
            self.append_info("Manufacturer:", port.manufacturer())
            self.append_info("Description:", port.description())
            self.append_html("<br>")

        self.append_html("<br>")
        self.append_html("<hr>")

    def new_terminal(self) -> None:
        subprocess.Popen([f"{self_dir}/mpterm"], shell=False)


def list_ports() -> None:
    spi = QSerialPortInfo.availablePorts()
    for p in spi:
        print(f"{p.portName():<10}{p.description():<20}{p.systemLocation()}")


def main() -> None:
    logging_format = "[%(levelname)s] %(lineno)4d %(funcName)-16s : %(message)s"

    # options parsing
    parser = argparse.ArgumentParser(
        prog=App.NAME, add_help=True, description=App.DESCRIPTION
    )
    parser.add_argument(
        "--version", action="version", version=f"%(prog)s {App.VERSION}"
    )
    parser.add_argument("--info", action="store_true", help="Information about script")
    parser.add_argument(
        "--suspend", action="store_true", help="Send signal to suspend port temporary"
    )
    parser.add_argument("--list", action="store_true", help="List serialports")
    parser.add_argument("--debug", action="store_true", help="Activate debug printout")
    parser.add_argument(
        "--ext-program",
        action="store",
        type=str,
        dest="ext_program",
        help="Set external program to execute when signaled",
        default="",
    )
    parser.add_argument(
        "--exec-program",
        action="store_true",
        help="Send signal to initiate external program execution",
    )

    args = parser.parse_args()

    if args.debug:
        logging.basicConfig(format=logging_format, level=logging.DEBUG)

    if args.list:
        list_ports()
        sys.exit()

    if args.suspend:
        with os.popen("ps aux | grep mpterm | grep -v -e 'grep' -e '--suspend'") as f:
            res = f.readlines()

        for r in res:
            pid = int(r.split()[1])
            logging.debug(f"Sending suspend signal to process pid={pid}")
            os.kill(pid, signal.SIGUSR1)

        sys.exit()

    if args.exec_program:
        with os.popen(
            "ps aux | grep mpterm | grep -v -e 'grep' -e '--exec-program'"
        ) as f:
            res = f.readlines()

        for r in res:
            pid = int(r.split()[1])
            logging.debug(f"Sending suspend signal to process pid={pid}")
            os.kill(pid, signal.SIGUSR2)

        sys.exit()

    app = QApplication(sys.argv)
    app.setStyle(
        "Fusion"
    )  # 'cleanlooks', 'gtk2', 'cde', 'motif', 'plastique', 'qt5ct-style', 'Windows', 'Fusion'
    app.setAttribute(Qt.AA_UseHighDpiPixmaps)

    mainForm = MainForm(args)
    mainForm.args = args
    mainForm.show()
    sys.exit(app.exec_())


# Main run_ext_program handle
if __name__ == "__main__":
    try:
        main()
        sys.exit(0)
    except KeyboardInterrupt as e:  # Ctrl-C
        raise e
    except SystemExit as e:  # sys.exit()
        raise e
    except Exception as e:
        print("ERROR, UNEXPECTED EXCEPTION")
        print(str(e))
        traceback.print_exc()
        os._exit(1)

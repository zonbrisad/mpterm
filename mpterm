#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# -----------------------------------------------------------------------
#
# Serial terminal
#
# File:    mpterm
# Author:
# Date:    2017-05-29
# License:
# Python:  >=3
# QT       5
#
# -----------------------------------------------------------------------
# This file is generated from pyplate Python template generator.
# Pyplate is developed by
# Peter Malmberg <peter.malmberg@gmail.com>
#

# Imports --------------------------------------------------------------------

import sys
import os
import subprocess
import traceback
import logging
import argparse
import signal
import enum
import json

# from datetime import datetime, date, time
from typing import Callable

from PyQt5.QtCore import (
    Qt,
    QTimer,
    QProcess,
    QEvent,
    QObject,
)
from PyQt5.QtGui import QIcon, QKeyEvent, QCloseEvent
from PyQt5.QtWidgets import (
    QApplication,
    QCheckBox,
    QMainWindow,
    QInputDialog,
    QDialog,
    QVBoxLayout,
    QHBoxLayout,
    QMenu,
    QMenuBar,
    QAction,
    QStatusBar,
    QLabel,
    QDialogButtonBox,
    QPushButton,
    QComboBox,
    QWidget,
    QLineEdit,
    QSizePolicy,
)

try:
    from PyQt5.QtSerialPort import QSerialPort, QSerialPortInfo
except ModuleNotFoundError:
    print("Lib qtserialport not installed")
    print(">apt install python3-pyqt5.qtserialport")
    exit(0)

from dataclasses import dataclass, field
from escape import (
    Ansi,
    Ascii,
    flag,
)
from qterminalwidget import QTerminalWidget, get_key
from serialport import SerialPort
from aboutdialog import AboutDialog
from qedit import QHexEdit, QNumberEdit
from mppluginframe import MpPluginFrame

# Settings ------------------------------------------------------------------

# Absolute path to script itself
self_dir = os.path.abspath(os.path.dirname(sys.argv[0]))


class App:
    NAME = "mpterm"
    VERSION = "0.51"
    DESCRIPTION = "MpTerm is a simple serial terminal program, aimed at embedded systems development"
    LICENSE = ""
    AUTHOR = "Peter Malmberg"
    EMAIL = "peter.malmberg@gmail.com"
    ORG = ""
    HOME = "github.com/zonbrisad/mpterm"
    ICON = f"{self_dir}/icons/mp_icon2_128x128.png"
    MAX_LINES = 150
    RECEIVE_BUFFER = 256
    MACROS = 5
    SETTINGS_FILE = f"{self_dir}/mpterm.json"


# Definitions ---------------------------------------------------------------


class MpState(enum.Enum):
    DISCONNECTED = 0
    CONNECTED = 1
    SUSPENDED = 2
    RECONNECTING = 3
    EXTERNAL = 4
    PAUSED = 5


class MpStateManager:
    def __init__(self, state: MpState) -> None:
        self.state = state
        self.old_state = None

    def set_state(self, state: MpState) -> None:
        self.old_state = self.state
        self.state = state

    def get_old_state(self) -> MpState:
        return self.old_state


class Mode(enum.Enum):
    Normal = 0
    Echo = 1


class MpTerm(enum.Enum):
    # Display modes
    Ascii = "Ascii"
    Hex = "Hex"
    AsciiHex = "AsciiHex"
    Terminal = "Terminal"

    # Newline modes
    Nl = 0
    Cr = 1
    NlCr = 2


about_html = f"""
<center><img src={App.ICON} width="54" height="54"></center>
<center><h2>{App.NAME}</h2></center>
<br>
{App.DESCRIPTION}
<br>
<hr>

<table>
  <tr>
    <td>
      <b>Version: </b>
    </td>
    <td>
      {App.VERSION}
    </td>
  </tr>
  <tr>
    <td>
      <b>Author: </b>
    </td>
    <td>
      {App.AUTHOR}
    </td/
  </tr>
  <tr>
    <td>
      <b>Email: </b>
    </td>
    <td> 
      </b><a href="{App.EMAIL}">{App.EMAIL}</a>
    </td/
  </tr>
  <tr>
    <td>
      <b>Github: </b>
    </td>
    <td> 
      <a href="{App.HOME}">{App.HOME}</a>
    </td/
    </td>
  </tr>
</table>
"""

# Code ----------------------------------------------------------------------


@dataclass
class Macro:
    name: str = ""
    text: str = ""
    hex: bool = False
    repeat: bool = False
    intervallEdit: int = 1000

    @staticmethod
    def is_hex_string(data: str) -> bool:
        try:
            Macro.hexstring_to_list(data)
        except ValueError:
            return False

        return True

    @staticmethod
    def hexstring_to_list(data: str) -> list[int]:
        tokens = data.strip().split(" ")
        lst = []
        for token in tokens:
            val = int(token, 16)
            if val < 0 or val > 255:
                raise ValueError
            lst.append(val)

        return lst

    def data(self) -> bytearray:
        if self.hex is True:
            tokens = self.text.strip().split(" ")
            hs = []
            try:
                for token in tokens:
                    h = int(token, 16)
                    hs.append(h)
            except ValueError:
                hs = []

            # print(hs)
            return bytearray(hs)

        return bytearray(
            self.text.replace("\\n", "\n")
            .replace("\\e", "\x1b")
            .replace("\\x1b", "\x1b"),
            "utf-8",
        )


@dataclass
class mpProfile:
    alias: str = "default"
    port: str = ""
    bitrate: str = "38400"
    databits: str = "8"
    parity: str = "None"
    stopbits: str = "1"
    flowcontrol: str = "None"
    mode: str = MpTerm.Ascii.name
    suspend_timeout: int = 8
    ext_program: str = ""
    newline: str = "\n"
    win_x: int = 850
    win_y: int = 500
    sync_string: str = ""
    columns: int = 10
    macros: list[Macro] = field(default_factory=list)
    plugin: str = ""
    key_list = [
        "alias",
        "port",
        "bitrate",
        "databits",
        "parity",
        "stopbits",
        "flowcontrol",
        "mode",
        "suspend_timeout",
        "ext_program",
        "newline",
        "win_x",
        "win_y",
        "sync_string",
        "columns",
        "plugin",
    ]
    filename: str = ""

    def __post_init__(self):
        for nm in range(App.MACROS):
            m = Macro(name=f"M{nm}")
            self.macros.append(m)

    def set_member(self, key, dict):
        val = dict.get(key, getattr(self, key))
        logging.debug(f"{key} = {val}")
        setattr(self, key, val)

    def to_json(self) -> dict:
        jsonDict = {}
        for key in self.key_list:
            jsonDict[key] = getattr(self, key)

        macro_dicts = []
        for macro in self.macros:
            macro_dict = {}
            macro_dict["name"] = macro.name
            macro_dict["hex"] = macro.hex
            macro_dict["text"] = macro.text
            macro_dicts.append(macro_dict)
        jsonDict["macros"] = macro_dicts
        return jsonDict

    def from_json(self, jsonDict):
        for key in self.key_list:
            self.set_member(key, jsonDict)

        macro_dicts = jsonDict["macros"]
        for mc, md in zip(self.macros, macro_dicts):
            mc.name = md["name"]
            mc.text = md["text"]
            mc.hex = md["hex"]
            # print(md)

    def write(self):
        with open(self.filename, "w") as outfile:
            json.dump(self.to_json(), outfile, indent=4)

    def load(self):
        if not os.path.exists(self.filename):
            self.write()

        with open(self.filename, "r") as infile:
            jsd = json.load(infile)

        self.from_json(jsd)


class HexMode(enum.Enum):
    Length = 1
    SynchAfter = 2
    SynchBefore = 3


class HexFormater:
    def __init__(self) -> None:
        self.end = "<br>"
        self.sync_string = []
        self.mode = HexMode.Length
        self.set_mode(MpTerm.Ascii)
        self.set_columns(12)
        self.clear()

    def set_mode(self, mode: MpTerm) -> None:
        self.mode = mode
        self.index = 1

    def clear(self) -> None:
        self.index = 1
        self.sync_index = 0
        self.sync_list = []

    def append(self, chr: str) -> None:
        self.chars.append(chr)

    def append_byte(self, chd) -> None:
        if self.index >= self.max:
            self.clear()
            self.append(f"{self.get_char(chd)}<br>")
            return

        self.append(f"{self.get_char(chd)} ")
        self.index += 1

    def set_columns(self, cols: int) -> None:
        self.max = cols

    def set_sync_string(self, sync: list[int]) -> None:
        self.sync_string = sync

    def get(self, byte: int) -> str:

        if byte == 0x3C:  # Less than '<'
            return "'&lt;'"

        symbol = Ascii.symbol(byte)
        if symbol is None:
            if byte < 128:
                return f"'{chr(byte)}'"
            else:
                return "---"
        return symbol

    def get_char(self, byte: int) -> str:
        if self.mode == MpTerm.Hex:
            return f"{byte:02x}"

        if self.mode == MpTerm.AsciiHex:
            ch = self.get(byte)
            return f"<b>{byte:02x}</b> {ch:3}"

    def format(self, data: bytearray) -> str:
        self.chars = []
        for i in range(0, data.count()):
            byte = int.from_bytes(data.at(i), "big")

            # if syncstring empty just printout
            if len(self.sync_string) == 0:
                self.append_byte(byte)
                self.sync_index = 0
                continue

            if byte == self.sync_string[self.sync_index]:
                self.sync_index += 1
            else:
                if self.sync_index > 0:
                    for i in range(self.sync_index):
                        self.append_byte(self.sync_string[i])
                self.append_byte(byte)
                self.sync_index = 0

            # sync is complete, append newline
            if self.sync_index == len(self.sync_string):
                self.sync_index = 0
                self.append("<br>")
                self.clear()
                for sbyte in self.sync_string:
                    self.append_byte(sbyte)

        return f"<pre>{''.join(self.chars)}</pre>"


class StyleS:
    normal = """
    QLineEdit:enabled {
    color:Blask;
    }
    QLineEdit:disabled {
    color:gray;
    }
    """
    error = """
    QLineEdit:enabled {
    color:Red;
    }
    QLineEdit:disabled {
    color:gray;
    }
    """
    win = "border:0"


qt_style_sheet = """
QToolTip{
    color: black;
    background-color: LightYellow;
    padding: 1px;
    border: 0px solid black;
}
"""


class QMacroButton(QWidget):
    def __init__(self, macro: Macro, parent=None):
        super().__init__()
        self.macro = macro
        self.layout = QHBoxLayout()
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.layout.setSpacing(2)
        self.setLayout(self.layout)

        self.setSizePolicy(QSizePolicy.MinimumExpanding, QSizePolicy.Minimum)

        self.macroButton = QPushButton(macro.name)
        self.macroButton.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)
        self.layout.addWidget(self.macroButton)
        self.repeatButton = QPushButton("R")
        self.repeatButton.setSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)

        self.layout.addWidget(self.repeatButton)


class MacroEditWidget(QWidget):
    def __init__(self, macro: Macro, parent=None):
        super().__init__()
        self.macro = macro
        self.layout = QHBoxLayout()
        self.layout.setContentsMargins(2, 2, 2, 2)
        # self.layout.setSpacing(2)
        self.setLayout(self.layout)

        self.name = QLabel(macro.name)
        self.macro_edit = QLineEdit(macro.text)
        self.macro_edit.textChanged.connect(self.macroChanged)
        self.hexModeCb = QCheckBox("Hex")
        self.hexModeCb.stateChanged.connect(self.macroChanged)
        self.repeatCb = QCheckBox("Repeat")

        self.intervallEdit = QLineEdit(str(macro.intervallEdit))
        self.intervallEdit.textChanged.connect(self.intervallChanged)
        self.intervallEdit.setMaximumWidth(40)
        # self.setMaxLength(4)
        # self.setSizePolicy(5)

        self.layout.addWidget(self.name)
        self.layout.addWidget(self.macro_edit)
        self.layout.addWidget(self.hexModeCb)
        # self.layout.addWidget(self.repeatCb)
        # self.layout.addWidget(self.intervallEdit)

    def intervallChanged(self, a0: str) -> None:
        if self.intervallEdit.text().isnumeric():
            self.intervallEdit.setStyleSheet(StyleS.normal)
        else:
            self.intervallEdit.setStyleSheet(StyleS.error)

    def update(self) -> None:
        self.macro_edit.setText(self.macro.text)
        self.hexModeCb.setChecked(self.macro.hex)

    def hex_mode(self) -> bool:
        return self.hexModeCb.isChecked()

    def hex_mode_changed(self, a0: str) -> None:
        self.macroChanged()

    def macroChanged(self) -> None:
        if self.hex_mode() is True:
            if Macro.is_hex_string(self.macro_edit.text()) is True:
                self.macro_edit.setStyleSheet(StyleS.normal)
            else:
                self.macro_edit.setStyleSheet(StyleS.error)
        else:
            self.macro_edit.setStyleSheet(StyleS.normal)

    def accept(self) -> None:
        self.macro.text = self.macro_edit.text()
        self.macro.hex = self.hexModeCb.isChecked()


class MacroDialog(QDialog):
    def __init__(self, parent, macros) -> None:
        super().__init__(parent=parent)
        self.setWindowTitle("Userdefined Macros")
        # self.setWindowIcon(QIcon(App.ICON))
        self.setMinimumWidth(600)
        self.macros = macros
        self.main_layout = QVBoxLayout()
        # self.main_layout.setSpacing(2)
        self.setLayout(self.main_layout)

        self.macro_edits = []
        for macro in self.macros:
            mew = MacroEditWidget(macro)
            self.main_layout.addWidget(mew)
            self.macro_edits.append(mew)

        self.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.buttonBox.accepted.connect(self.accept)
        self.buttonBox.rejected.connect(self.reject)
        self.main_layout.addWidget(self.buttonBox)

    def exec(self, macros) -> int:
        for macro_edit in self.macro_edits:
            macro_edit.update()

        return super().exec()

    def accept(self):
        for macro_edit in self.macro_edits:
            macro_edit.accept()

        self.close()


class MainForm(QMainWindow):
    # Handle windows close event
    def closeEvent(self, a0: QCloseEvent) -> None:
        self.save_settings()
        return super().closeEvent(a0)

    def add_label_combobox(self, label_text: str) -> QComboBox:
        label = QLabel(self.central_widget)
        label.setText(f"<b>{label_text}:</b>")
        label.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        self.port_layout.addWidget(label)
        combobox = QComboBox(self.central_widget)
        combobox.setEditable(False)
        combobox.setCurrentText("")
        self.port_layout.addWidget(combobox)
        return combobox

    def add_action(
        self,
        name: str,
        menu: QMenu,
        trig: Callable = None,
        tip: str = "",
        shortcut: str = "",
    ) -> QAction:
        action = QAction(name, self)
        action.triggered.connect(trig)
        action.setStatusTip(tip)
        action.setShortcut(shortcut)
        menu.addAction(action)
        return action

    def __init__(self, args, parent=None) -> None:
        super(MainForm, self).__init__(parent)

        self.prof = mpProfile(filename=App.SETTINGS_FILE)
        self.prof.load()

        self.serial_port = SerialPort()
        self.serial_port.setReadBufferSize(256)
        self.serial_port.readyRead.connect(self.read)

        self.state = MpState.DISCONNECTED
        self.old_state = MpState.DISCONNECTED

        self.resize(self.prof.win_x, self.prof.win_y)
        self.setWindowIcon(QIcon(App.ICON))
        self.setContentsMargins(2, 2, 2, 2)
        self.setStyleSheet(qt_style_sheet)

        self.central_widget = QWidget(self)
        self.setCentralWidget(self.central_widget)

        # Layouts
        self.main_layout = QVBoxLayout(self.central_widget)
        self.main_layout.setSpacing(2)
        self.main_layout.setContentsMargins(0, 0, 0, 0)

        self.middle_layout = QHBoxLayout(self.central_widget)

        # Port settings layout (above)
        self.port_layout = QHBoxLayout(self.central_widget)
        self.port_layout.setSpacing(10)
        self.port_layout.addStretch()

        # "Buttons" layout (to the left)
        self.button_layout = QVBoxLayout(self.central_widget)
        self.button_layout.addSpacing(10)

        # Terminal layout (middle)
        self.terminal_layout = QVBoxLayout(self.central_widget)

        # Macro layout (to the right)
        self.macro_layout = QVBoxLayout(self.central_widget)
        self.macro_layout.addSpacing(20)

        self.middle_layout.addLayout(self.button_layout)
        self.middle_layout.addLayout(self.terminal_layout)
        self.middle_layout.addLayout(self.macro_layout)

        self.main_layout.addLayout(self.port_layout)
        self.main_layout.addLayout(self.middle_layout)

        # Port layout widgets
        self.cb_port = self.add_label_combobox("Port")
        self.cb_bitrate = self.add_label_combobox("Bitrate")
        self.cb_bitrate.addItem("300", 300)
        self.cb_bitrate.addItem("600", 600)
        self.cb_bitrate.addItem("1200", 1200)
        self.cb_bitrate.addItem("2400", 2400)
        self.cb_bitrate.addItem("4800", 4800)
        self.cb_bitrate.addItem("9600", 9600)
        self.cb_bitrate.addItem("19200", 19200)
        self.cb_bitrate.addItem("28400", 28400)
        self.cb_bitrate.addItem("57600", 57600)
        self.cb_bitrate.addItem("115200", 115200)
        self.cb_bitrate.setCurrentIndex(5)
        self.cb_bitrate.activated.connect(self.set_sp)

        self.cb_bits = self.add_label_combobox("Bits")
        self.cb_bits.addItem("5", QSerialPort.Data5)
        self.cb_bits.addItem("6", QSerialPort.Data6)
        self.cb_bits.addItem("7", QSerialPort.Data7)
        self.cb_bits.addItem("8", QSerialPort.Data8)
        self.cb_bits.setCurrentIndex(3)
        self.cb_bits.activated.connect(self.set_sp)

        self.cb_stop_bits = self.add_label_combobox("StopBit")
        self.cb_stop_bits.addItem("1", QSerialPort.OneStop)
        self.cb_stop_bits.addItem("1.5", QSerialPort.OneAndHalfStop)
        self.cb_stop_bits.addItem("2", QSerialPort.TwoStop)
        self.cb_stop_bits.setCurrentIndex(0)
        self.cb_stop_bits.activated.connect(self.set_sp)

        self.cb_parity = self.add_label_combobox("Parity")
        self.cb_parity.addItem("None", QSerialPort.NoParity)
        self.cb_parity.addItem("Odd", QSerialPort.OddParity)
        self.cb_parity.addItem("Even", QSerialPort.EvenParity)
        self.cb_parity.setCurrentIndex(0)
        self.cb_parity.activated.connect(self.set_sp)

        self.cb_flow_control = self.add_label_combobox("HwFlow")
        self.cb_flow_control.addItem("None", QSerialPort.NoFlowControl)
        self.cb_flow_control.addItem("Hardware", QSerialPort.HardwareControl)
        self.cb_flow_control.addItem("Software", QSerialPort.SoftwareControl)
        self.cb_flow_control.setCurrentIndex(0)
        self.cb_flow_control.activated.connect(self.set_sp)
        self.port_layout.addStretch()

        # Middle layout widgets
        #
        self.terminal = QTerminalWidget(self.central_widget)
        self.terminal.setMaxLines(App.MAX_LINES)
        self.terminal_layout.addWidget(self.terminal)

        # Button layout widgets
        #
        self.pb_open = QPushButton("Open", self.central_widget)
        self.pb_open.setFixedHeight(50)
        self.pb_open.pressed.connect(self.open_port)
        self.pb_open.setToolTip("Open/Close current serial port")
        self.button_layout.addWidget(self.pb_open)

        self.cb_echo_mode = QComboBox(self.central_widget)
        self.cb_echo_mode.addItem(Mode.Normal.name, Mode.Normal)
        self.cb_echo_mode.addItem(Mode.Echo.name, Mode.Echo)
        self.button_layout.addWidget(self.cb_echo_mode)

        self.cb_display_mode = QComboBox(self.central_widget)
        self.cb_display_mode.addItem("Ascii", MpTerm.Ascii)
        self.cb_display_mode.addItem("Hex", MpTerm.Hex)
        self.cb_display_mode.addItem("Hex + Ascii", MpTerm.AsciiHex)
        self.cb_display_mode.currentIndexChanged.connect(self.mode_change)
        self.cb_display_mode.activated.connect(self.set_sp)
        self.button_layout.addWidget(self.cb_display_mode)

        self.cb_line_mode = QComboBox(self.central_widget)
        self.cb_line_mode.addItem("LF", "\n")
        self.cb_line_mode.addItem("CR", "\r")
        self.cb_line_mode.addItem("CRLF", "\r\n")
        self.button_layout.addWidget(self.cb_line_mode)

        self.ed_line_length = QNumberEdit(self.centralWidget)
        self.ed_line_length.set_value(self.prof.columns)
        self.button_layout.addWidget(self.ed_line_length)

        self.ed_synch_string = QHexEdit(self.centralWidget)
        self.ed_synch_string.setText(self.prof.sync_string)
        self.button_layout.addWidget(self.ed_synch_string)

        self.plugin_widget = MpPluginFrame(
            self.central_widget, self.serial_port, self.terminal
        )
        # self.plugin_widget = MpPluginFrame(
        #     self.central_widget, self.serial_port, self.terminal
        # )
        self.button_layout.addWidget(self.plugin_widget)
        self.button_layout.addStretch()

        # self.dtrLabel = QLabel("\u26D4 DTR")
        # self.rtsLabel = QLabel("\u26D4 RTS")

        # self.cbRTS = QCheckBox(self.central_widget)
        # self.cbRTS.setText("RTS")
        # self.cbRTS.clicked.connect(self.handle_rts)

        # self.cbDTR = QCheckBox(self.central_widget)
        # self.cbDTR.setText("DTR")
        # self.cbDTR.setCheckable(True)
        # self.cbDTR.setChecked(False)
        # self.cbDTR.setTristate(False)
        # self.cbDTR.clicked.connect(self.handle_dtr)

        self.pb_external = QPushButton("External", self.central_widget)
        self.pb_external.pressed.connect(self.external_program)
        self.pb_external.setToolTip("Run external program")
        self.button_layout.addWidget(self.pb_external)

        self.pb_suspend = QPushButton("Suspend", self.central_widget)
        self.pb_suspend.pressed.connect(self.terminal_suspend)
        self.pb_suspend.setToolTip(f"Suspend port for {self.prof.suspend_timeout} s")
        self.button_layout.addWidget(self.pb_suspend)

        # self.cbProfiles = QComboBox(self.central_widget)
        # self.cbProfiles.setObjectName("cbProfiles")
        # self.cbProfiles.addItem("Default", 0)
        # self.cbProfiles.addItem("115200", 2)
        # self.cbProfiles.addItem("New...", 3)
        # self.cbProfiles.hide()
        # self.button_layout.addWidget(self.cbNewline)
        # self.button_layout.addWidget(self.cbRTS)
        # self.button_layout.addWidget(self.cbDTR)
        # self.button_layout.addWidget(self.dtrLabel)
        # self.button_layout.addWidget(self.rtsLabel)

        # Macro layout widgets
        #
        for macro in self.prof.macros:
            macro_button = QPushButton(
                macro.name,
                self.central_widget,
                pressed=lambda m=macro: self.serial_port.send(m.data()),
            )
            self.macro_layout.addWidget(macro_button)

            # macro_button = QMacroButton(macro=macro)
            # self.macro_layout.addWidget(macro_button)

        self.macro_dialog = MacroDialog(self, self.prof.macros)
        self.macro_set = QPushButton("Edit macro's", self.central_widget)
        self.macro_set.pressed.connect(self.edit_macro_dialog)

        self.macro_layout.addSpacing(20)
        self.macro_layout.addWidget(self.macro_set)
        self.macro_layout.addStretch()

        self.bp_pause = QPushButton("Pause", self.central_widget)
        self.bp_pause.pressed.connect(self.terminal_pause)
        self.macro_layout.addWidget(self.bp_pause)

        # Status bar
        self.statusbar = QStatusBar(self)
        self.statusbar.setLayoutDirection(Qt.LeftToRight)
        self.statusbar.setStyleSheet(StyleS.normal)
        self.setStatusBar(self.statusbar)

        # Status bar elements
        self.label_state = QLabel("")
        self.statusbar.addPermanentWidget(self.label_state, stretch=0)
        self.label_rx = QLabel("")
        self.statusbar.addPermanentWidget(self.label_rx, stretch=0)
        self.label_tx = QLabel("")
        self.statusbar.addPermanentWidget(self.label_tx, stretch=0)
        self.label_dimensions = QLabel("")
        # self.dimensionsLabel.setToolTip("Terminal size")
        self.statusbar.addPermanentWidget(self.label_dimensions, stretch=0)
        # self.yyy = QComboBox(self.central_widget)
        # self.yyy.addItem("80x24", Mode.Normal)
        # self.yyy.addItem("132x24", Mode.Normal)
        # self.statusbar.addPermanentWidget(self.yyy)

        # Menubar
        menubar = QMenuBar(self)
        self.setMenuBar(menubar)

        # File menu
        menu_file = menubar.addMenu("&File")
        self.add_action("New", menu_file, self.new_terminal)
        self.add_action("Quit", menu_file, self.exit_program).setShortcutContext(
            Qt.WidgetShortcut
        )

        # Settings menu
        menu_settings = menubar.addMenu("Settings")
        self.add_action("Ext. Program", menu_settings, self.set_ext_program)
        self.add_action("Suspend timeout", menu_settings, self.set_suspend_timeout)

        # Action menu
        menu_action = menubar.addMenu("&Action")
        self.add_action("Clear", menu_action, self.terminal_clear)
        self.add_action("List ports", menu_action, self.port_info)

        # Send menu
        menu_send = menubar.addMenu("Send")
        self.add_action("Break [0x00]", menu_send, lambda: self.send_string(Ascii.NUL))
        self.add_action(
            "ETX [0x03] (Ctrl-C)", menu_send, lambda: self.send_string(Ascii.ETX)
        )
        self.add_action(
            "EOT [0x04] (Ctrl-D)", menu_send, lambda: self.send_string(Ascii.ETX)
        )
        self.add_action("Tab [0x09]", menu_send, lambda: self.send_string(Ascii.TAB))
        self.add_action("LF [0x0a]", menu_send, lambda: self.send_string(Ascii.LF))
        self.add_action("CR [0x0d]", menu_send, lambda: self.send_string(Ascii.CR))

        menu_tests = menu_send.addMenu("Tests")

        self.add_action(
            "Ascii table", menu_tests, lambda: self.send_string(Ascii.table())
        )
        self.add_action(
            "Escape test", menu_tests, lambda: self.send_string(Ansi.test())
        )
        self.add_action(
            "Color test", menu_tests, lambda: self.send_string(Ansi.color_test())
        )

        menu_terminal = menu_send.addMenu("Terminal")

        menu_color = menu_terminal.addMenu("Colors")
        self.add_action("Red", menu_color, lambda: self.send_string(Ansi.RED))
        self.add_action("Green", menu_color, lambda: self.send_string(Ansi.GREEN))
        self.add_action("Yellow", menu_color, lambda: self.send_string(Ansi.YELLOW))
        self.add_action("Blue", menu_color, lambda: self.send_string(Ansi.BLUE))
        self.add_action("Magenta", menu_color, lambda: self.send_string(Ansi.MAGENTA))
        self.add_action("Cyan", menu_color, lambda: self.send_string(Ansi.CYAN))
        self.add_action("White", menu_color, lambda: self.send_string(Ansi.WHITE))
        self.add_action("Bg Red", menu_color, lambda: self.send_string(Ansi.BG_RED))
        self.add_action("Bg Green", menu_color, lambda: self.send_string(Ansi.BG_GREEN))
        self.add_action(
            "Bg Yellow", menu_color, lambda: self.send_string(Ansi.BG_YELLOW)
        )
        self.add_action("Bg Blue", menu_color, lambda: self.send_string(Ansi.BG_BLUE))
        self.add_action(
            "Bg Magenta", menu_color, lambda: self.send_string(Ansi.BG_MAGENTA)
        )
        self.add_action("Bg Cyan", menu_color, lambda: self.send_string(Ansi.BG_CYAN))
        self.add_action("Bg White", menu_color, lambda: self.send_string(Ansi.BG_WHITE))

        menu_attr = menu_terminal.addMenu("Attributes")
        self.add_action("Reset", menu_attr, lambda: self.send_string(Ansi.RESET))
        self.add_action("Bold", menu_attr, lambda: self.send_string(Ansi.BOLD))
        self.add_action("Italic", menu_attr, lambda: self.send_string(Ansi.ITALIC))
        self.add_action("Dim", menu_attr, lambda: self.send_string(Ansi.DIM))
        self.add_action("Reverse", menu_attr, lambda: self.send_string(Ansi.REVERSE))
        self.add_action(
            "Underline", menu_attr, lambda: self.send_string(Ansi.UNDERLINE)
        )
        self.add_action("Crossed", menu_attr, lambda: self.send_string(Ansi.CROSSED))

        menu_attr = menu_terminal.addMenu("Cursor")
        self.add_action("Up", menu_attr, lambda: self.send_string(Ansi.UP))
        self.add_action("Down", menu_attr, lambda: self.send_string(Ansi.DOWN))
        self.add_action("Forward", menu_attr, lambda: self.send_string(Ansi.FORWARD))
        self.add_action(
            "Backward",
            menu_attr,
            lambda: self.send_string(Ansi.BACK),
        )

        # Plugin menu
        menu_plugins = menubar.addMenu("Plugins")
        self.add_action(
            "List plugins",
            menu_plugins,
            lambda: self.append_html_text(self.plugin_widget.plugins_to_str()),
        )

        # Help menu
        menu_help = menubar.addMenu("&Help")
        self.add_action(
            "About", menu_help, lambda: AboutDialog.about(App.NAME, about_html)
        )

        # Scan for serialports
        self.update_ports()
        self.formater = HexFormater()

        self.load_settings()
        self.mode_change()

        # If commandline argument use it instead of saved parameter
        if args.ext_program != "":
            self.prof.ext_program = args.ext_program

        # Configure signal handler
        signal.signal(signal.SIGUSR1, self.signal_usr1)
        signal.signal(signal.SIGUSR2, self.signal_usr2)

        # Timers
        self.timer = QTimer()
        self.timer.setInterval(1000)
        self.timer.timeout.connect(self.timer_event)
        self.timer.start()

        self.timer_5 = QTimer()
        self.timer_5.setInterval(200)
        self.timer_5.timeout.connect(self.timer_5_timeout)
        self.timer_5.start()

        self.suspend_timer = QTimer()
        self.suspend_timer.setSingleShot(True)
        self.suspend_timer.setInterval(self.prof.suspend_timeout * 1000)
        self.suspend_timer.timeout.connect(lambda: self.set_state(MpState.RECONNECTING))

        self.process = QProcess()
        self.process.setProcessChannelMode(QProcess.ProcessChannelMode.MergedChannels)
        self.process.readyReadStandardOutput.connect(self.program_stdout_available)
        # self.process.readyReadStandardError.connect(self.program_stderr_available)
        self.process.finished.connect(self.external_program_finished)

        self.terminal_paused = False

        self.terminal.installEventFilter(self)
        self.terminal.append_html_text(f"""MpTerm Ver: <b>{App.VERSION}</b><br><br>""")

        self.ui_handler()
        self.init_port()

    def eventFilter(self, obj: QObject, event: QEvent) -> bool:

        if event.type() == QEvent.KeyPress:
            keyEvent = QKeyEvent(event)
            if keyEvent.key() in [Qt.Key_Enter, Qt.Key_Return]:
                self.send_string(self.cb_line_mode.currentData())
                return True

            self.send_string(get_key(keyEvent))
            return True

        return False

    def set_state(self, new_state: MpState, timeout=-1) -> None:
        logging.debug(f"Set state: {new_state}")
        # traceback.print_exc()
        # if new_state == MpState.EXTERNAL:
        #     self.serial_port.close()

        if new_state == MpState.DISCONNECTED:
            self.serial_port.close()

        if new_state == MpState.SUSPENDED:
            self.serial_port.close()
            self.suspend_timer.start()

        if new_state in [
            MpState.CONNECTED,
            MpState.DISCONNECTED,
            MpState.RECONNECTING,
            MpState.EXTERNAL,
            MpState.PAUSED,
            MpState.SUSPENDED,
        ]:
            self.old_state = self.state
            self.state = new_state

    def state_handler(self) -> None:
        if self.state == MpState.RECONNECTING:
            self.init_port()
            self.serial_port.clear()

            if self.serial_port.open():
                self.message(
                    f"Opening port: /dev/{self.serial_port.portName()} {self.serial_port.baudRate()}"
                )
            else:
                self.message_error(
                    f"Failed to open port /dev/{self.serial_port.portName()}. {self.serial_port.error()}"
                )
            self.set_state(MpState.CONNECTED)

        if self.state == MpState.CONNECTED and not self.serial_port.isOpen():
            self.set_state(MpState.DISCONNECTED)

    def edit_macro_dialog(self) -> None:
        self.macro_dialog.exec(self.prof.macros)

    def set_suspend_timeout(self) -> None:
        dlg = QInputDialog()
        val, ok = dlg.getInt(
            self, "Suspend timeout", "Timeout (s)", value=self.prof.suspend_timeout
        )

        if ok is True:
            self.prof.suspend_timeout = val

    def set_ext_program(self) -> None:
        dlg = QInputDialog()
        val, ok = dlg.getText(
            self,
            "External program",
            "Commandline:",
            text=self.prof.ext_program,
        )
        if ok is True:
            self.prof.ext_program = val

    def send_macro(self, macro: Macro) -> None:
        self.serial_port.send(macro.data())

    def terminal_pause(self) -> None:
        if self.terminal_paused is True:
            self.terminal_paused = False
        else:
            self.terminal_paused = True

    def terminal_suspend(self) -> None:
        if self.state != MpState.CONNECTED:
            return

        logging.debug(f"Suspending port for {self.prof.suspend_timeout} s.")
        self.set_state(MpState.SUSPENDED, timeout=self.prof.suspend_timeout * 1000)
        self.ui_handler()

    def program_stdout_available(self) -> None:
        logging.debug("Program received stdout data")
        data = self.process.readAllStandardOutput()
        data_str = str(data, "utf-8")
        self.terminal.append_ansi_text(data_str)
        self.terminal.scroll_down()
        self.ui_handler()

    def external_program(self) -> None:

        if self.state in (MpState.SUSPENDED, MpState.EXTERNAL):
            return

        # If process is running, quit
        if self.process.state() != QProcess.ProcessState.NotRunning:
            self.process.setProcessState(QProcess.ProcessState.NotRunning)
            return

        if self.state == MpState.CONNECTED:
            self.serial_port.close()

        self.set_state(MpState.EXTERNAL)

        self.terminal.append_html_text("<br>")
        ext_prog = self.prof.ext_program.replace(
            "__PORT__", f"/dev/{self.serial_port.portName()}"
        )
        self.process.start(ext_prog)
        logging.debug(
            f"Running external program: {ext_prog}  {self.process.processId()}"
        )
        self.ui_handler()
        self.terminal.scroll_down()

    def external_program_finished(self) -> None:
        logging.debug("External program finnished executing")
        self.terminal.append_html_text("<br>")
        if self.old_state == MpState.CONNECTED:
            self.set_state(MpState.RECONNECTING)
        else:
            self.set_state(MpState.DISCONNECTED)

        self.ui_handler()

    def signal_usr1(self, signum, frame) -> None:
        logging.debug("USR1 signal received")
        self.terminal_suspend()

    def signal_usr2(self, signum, frame) -> None:
        logging.debug("USR2 signal received")
        self.external_program()

    def timer_5_timeout(self) -> None:
        self.ui_handler()
        self.state_handler()

    def port_handler(self) -> None:
        port_names = [port.portName() for port in QSerialPortInfo.availablePorts()]

        # Check if current port is still connecter (USB to serial adapters), if not close port
        if self.serial_port.isOpen():
            if self.serial_port.portName() not in port_names:
                self.serial_port.close()
                self.message_error(
                    f"Port {self.serial_port.portName()} no longer available."
                )

        # Update list of serialports in combobox
        for name in range(self.cb_port.count()):
            if self.cb_port.itemText(name) not in port_names:
                self.cb_port.removeItem(name)
            else:
                port_names.remove(self.cb_port.itemText(name))

        for name in port_names:
            self.cb_port.addItem(name)

    def timer_event(self) -> None:
        self.port_handler()

    def ui_handler(self) -> None:

        if self.state == MpState.DISCONNECTED:
            self.pb_open.setText("Open")

        if self.state == MpState.EXTERNAL:
            if self.old_state != MpState.DISCONNECTED:
                self.pb_open.setText("Close")
            else:
                self.pb_open.setText("Open")

        if self.state in [
            MpState.CONNECTED,
            MpState.RECONNECTING,
            MpState.SUSPENDED,
            MpState.PAUSED,
        ]:
            self.pb_open.setText("Close")

        if self.state == MpState.DISCONNECTED:
            self.setWindowTitle("MpTerm")
            # self.pb_open.setText("Open")
            self.cb_port.setEnabled(True)
        else:
            self.setWindowTitle(
                f"MpTerm  /dev/{self.cb_port.currentText()} {self.cb_bitrate.currentText()}"
            )
            # self.pb_open.setText("Close")
            self.cb_port.setEnabled(False)

        self.label_rx.setText(
            f'<span style="color:Black">RX:</span> <span style="color:Purple">{self.serial_port.cnt_rx:06d}</span> '
        )
        self.label_tx.setText(
            f'<span style="color:Black">TX:</span> <span style="color:Purple">{self.serial_port.cnt_tx:06d}</span> '
        )
        self.label_dimensions.setText(
            f'<span style="color:Black">{self.terminal.terminal_state.max.column:3d}x{self.terminal.terminal_state.max.row:2d}</span> '
        )

        states = {
            MpState.DISCONNECTED: f"""<span style="color:Black">Disconnected</span>""",
            MpState.CONNECTED: f"""<span style="color:Green">Connected  </span>""",
            MpState.SUSPENDED: f"""<span style="color:Red">Suspended {self.suspend_timer.remainingTime()/1000:.0f}</span>""",
            MpState.RECONNECTING: f"""<span style="color:Magenta">Reconnecting {self.serial_port.cntReconnect}</span>""",
            MpState.EXTERNAL: f"""<span style="color:Green">External </span>""",
        }
        self.label_state.setText(f"{states[self.state]}")

        if self.terminal_paused is True:
            self.bp_pause.setText("Paused")
        else:
            self.bp_pause.setText("Pause")

        self.formater.set_columns(self.ed_line_length.get_value())
        self.formater.set_sync_string(self.ed_synch_string.get_value())

        if self.plugin_widget.current_plugin() is None:
            self.cb_echo_mode.setEnabled(True)
            self.cb_display_mode.setEnabled(True)
            self.cb_line_mode.setEnabled(True)
            self.ed_line_length.setEnabled(True)
            self.ed_synch_string.setEnabled(True)
        else:
            self.cb_echo_mode.setEnabled(False)
            self.cb_display_mode.setEnabled(False)
            self.cb_line_mode.setEnabled(False)
            self.ed_line_length.setEnabled(False)
            self.ed_synch_string.setEnabled(False)

        # if self.serial_port.isDataTerminalReady():
        #     self.dtrLabel.setText("\u26AA  DTR")
        # else:
        #     self.dtrLabel.setText("\u26AB  DTR")

        # if self.serial_port.isRequestToSend():
        #     self.rtsLabel.setText("\u26AA  RTS")
        # else:
        #     self.rtsLabel.setText("\u26AB  RTS")

        # logging.debug(f"DTR: {self.sp.serial_port.isDataTerminalReady()}  RTS: {self.sp.serial_port.isRequestToSend()}")

    # def update_ui(self) -> None:

    #     if self.serial_port.state == State.DISCONNECTED:
    #         self.setWindowTitle("MpTerm")
    #         self.pb_open.setText("Open")
    #         self.cb_port.setEnabled(True)
    #     else:
    #         self.setWindowTitle(
    #             f"MpTerm  /dev/{self.cb_port.currentText()} {self.cb_bitrate.currentText()}"
    #         )
    #         self.pb_open.setText("Close")
    #         self.cb_port.setEnabled(False)

    #     self.label_rx.setText(
    #         f'<span style="color:Black">RX:</span> <span style="color:Purple">{self.serial_port.cnt_rx:06d}</span> '
    #     )
    #     self.label_tx.setText(
    #         f'<span style="color:Black">TX:</span> <span style="color:Purple">{self.serial_port.cnt_tx:06d}</span> '
    #     )
    #     self.label_dimensions.setText(
    #         f'<span style="color:Black">{self.terminal.terminal_state.max.column:3d}x{self.terminal.terminal_state.max.row:2d}</span> '
    #     )

    #     states = {
    #         State.DISCONNECTED: f"""<span style="color:Black">Disconected</span>""",
    #         State.CONNECTED: f"""<span style="color:Green">Connected  </span>""",
    #         State.SUSPENDED: f"""<span style="color:Red">Suspended {self.serial_port.suspend_timer.remainingTime()/1000:.0f}</span>""",
    #         State.RECONNECTING: f"""<span style="color:Magenta">Reconnecting {self.serial_port.cntReconnect}</span>""",
    #     }
    #     self.label_state.setText(f"{states[self.serial_port.state]}")

    #     if self.terminal_paused is True:
    #         self.bp_pause.setText("Paused")
    #     else:
    #         self.bp_pause.setText("Pause")

    #     self.formater.set_columns(self.ed_line_length.get_value())
    #     self.formater.set_sync_string(self.ed_synch_string.get_value())

    #     if self.plugin_widget.current_plugin() is None:
    #         self.cb_echo_mode.setEnabled(True)
    #         self.cb_display_mode.setEnabled(True)
    #         self.cb_line_mode.setEnabled(True)
    #         self.ed_line_length.setEnabled(True)
    #         self.ed_synch_string.setEnabled(True)
    #     else:
    #         self.cb_echo_mode.setEnabled(False)
    #         self.cb_display_mode.setEnabled(False)
    #         self.cb_line_mode.setEnabled(False)
    #         self.ed_line_length.setEnabled(False)
    #         self.ed_synch_string.setEnabled(False)

    #     # if self.serial_port.isDataTerminalReady():
    #     #     self.dtrLabel.setText("\u26AA  DTR")
    #     # else:
    #     #     self.dtrLabel.setText("\u26AB  DTR")

    #     # if self.serial_port.isRequestToSend():
    #     #     self.rtsLabel.setText("\u26AA  RTS")
    #     # else:
    #     #     self.rtsLabel.setText("\u26AB  RTS")

    #     # logging.debug(f"DTR: {self.sp.serial_port.isDataTerminalReady()}  RTS: {self.sp.serial_port.isRequestToSend()}")

    def update_ports(self) -> None:
        ports = QSerialPortInfo.availablePorts()
        for port in ports:
            self.cb_port.addItem(port.portName())

    def handle_dtr(self) -> None:
        # self.ui.cbDTR.clicked.connect(self.handle_dtr)
        logging.debug("DTR")
        if self.cbDTR.isChecked():
            self.cbDTR.setChecked(True)
            self.serial_port.setDataTerminalReady(True)
        else:
            self.cbDTR.setChecked(False)
            self.serial_port.setDataTerminalReady(False)

    def handle_rts(self) -> None:
        logging.debug("RTS")
        if self.cbRTS.isChecked():
            self.cbRTS.setChecked(True)
            self.serial_port.setRequestToSend(True)
        else:
            self.cbRTS.setChecked(False)
            self.serial_port.setRequestToSend(False)

    def terminal_clear(self) -> None:
        self.terminal.clear()
        self.formater.clear()
        self.serial_port.clear_counters()
        self.update()

    def _message(self, name: str) -> None:
        self.statusbar.showMessage(name, 4000)
        self.statusbar.show

    # Show message in status bar
    def message(self, name: str) -> None:
        self.statusbar.setStyleSheet(StyleS.normal)
        self._message(name)
        logging.debug(name)

    # Show error message in status bar
    def message_error(self, name: str) -> None:
        self.statusbar.setStyleSheet(StyleS.error)
        self._message(name)
        logging.error(name)

    def mode_change(self) -> None:
        self.terminal.clear()
        self.formater.set_mode(self.cb_display_mode.currentData())
        logging.debug(f"Setting display mode {self.cb_display_mode.currentData()}")

    def append_html_text(self, text: str) -> None:
        self.terminal.append_html_text(text)
        self.terminal.scroll_down()

    def read(self) -> None:
        data = self.serial_port.read()
        try:
            data_str = str(data, "utf-8")
        except UnicodeDecodeError:
            data_str = ""
            pass

        logging.debug(f'Data received: {len(data)} "{Ansi.to_str(data_str)}"')

        if self.terminal_paused:
            self.ui_handler()
            return

        plugin = self.plugin_widget.current_plugin()
        if plugin is not None:
            self.terminal.append_html_text(plugin.data(data))
        else:
            DisplayMode = self.cb_display_mode.currentData()
            if DisplayMode == MpTerm.Ascii:  # Standard ascii display mode
                self.terminal.append_ansi_text(data_str)

            if DisplayMode == MpTerm.AsciiHex:  # Ascii + Hex display mode
                self.terminal.append_html_text(self.formater.format(data))

            if DisplayMode == MpTerm.Hex:  # Hexadecimal display mode
                self.terminal.append_html_text(self.formater.format(data))

        if self.cb_echo_mode.currentData() == Mode.Echo:
            self.serial_port.send(data)

        self.terminal.scroll_down()
        self.ui_handler()

    def send(self, data: bytearray) -> None:
        self.serial_port.send(data)
        self.ui_handler()

    def send_string(self, data: str) -> None:
        if self.process.state() == QProcess.Running:
            self.process.write(data.encode())
            return

        self.send(bytearray(data, "utf-8"))

    def open_port(self) -> None:

        if self.state in [MpState.EXTERNAL, MpState.SUSPENDED]:
            return

        if self.state == MpState.CONNECTED:
            self.set_state(MpState.DISCONNECTED)
            self.serial_port.close()
            self.ui_handler()
            return

        self.serial_port.clear()
        self.init_port()
        res = self.serial_port.open()
        if res:
            self.message(
                f"Opening port: /dev/{self.serial_port.portName()} {self.serial_port.baudRate()}"
            )
        else:
            self.message_error(
                f"Failed to open port /dev/{self.serial_port.portName()}. {self.serial_port.error()}"
            )
        self.set_state(MpState.CONNECTED)
        self.ui_handler()

    def init_port(self) -> None:
        self.set_port()
        self.set_sp()

    def set_port(self) -> None:
        self.serial_port.setPortName(f"/dev/{self.cb_port.currentText()}")

    def set_sp(self) -> None:
        self.serial_port.setBaudRate(self.cb_bitrate.currentData())
        self.serial_port.setStopBits(self.cb_stop_bits.currentData())
        self.serial_port.setDataBits(self.cb_bits.currentData())
        self.serial_port.setParity(self.cb_parity.currentData())
        self.serial_port.setFlowControl(self.cb_flow_control.currentData())
        logging.debug(self.cb_bitrate.currentData())

    def save_settings(self) -> None:
        self.prof.port = self.cb_port.currentText()
        self.prof.bitrate = self.cb_bitrate.currentText()
        self.prof.databits = self.cb_bits.currentText()
        self.prof.stopbits = self.cb_stop_bits.currentText()
        self.prof.parity = self.cb_parity.currentText()
        self.prof.flowcontrol = self.cb_flow_control.currentText()
        self.prof.mode = self.cb_display_mode.currentData().name
        self.prof.newline = self.cb_line_mode.currentText()
        self.prof.win_x = self.width()
        self.prof.win_y = self.height()
        self.prof.sync_string = self.ed_synch_string.text()
        self.prof.columns = self.ed_line_length.get_value()
        self.prof.plugin = self.plugin_widget.current_plugin_name()
        self.prof.write()

    def load_cb_setting(self, cb: QComboBox, setting: str) -> None:
        idx = cb.findText(setting)
        if idx != -1:
            cb.setCurrentIndex(idx)

    def load_settings(self) -> None:
        self.load_cb_setting(self.cb_bitrate, self.prof.bitrate)
        self.load_cb_setting(self.cb_bitrate, self.prof.bitrate)
        self.load_cb_setting(self.cb_port, self.prof.port)
        self.load_cb_setting(self.cb_stop_bits, self.prof.stopbits)
        self.load_cb_setting(self.cb_bits, self.prof.databits)
        self.load_cb_setting(self.cb_parity, self.prof.parity)
        self.load_cb_setting(self.cb_flow_control, self.prof.flowcontrol)
        self.load_cb_setting(self.cb_line_mode, self.prof.newline)

        idx = self.cb_display_mode.findData(MpTerm(self.prof.mode))
        self.cb_display_mode.setCurrentIndex(idx)

        self.plugin_widget.set_plugin(self.prof.plugin)

    def exit_program(self, e) -> None:
        self.serial_port.close()
        self.close()

    def port_info(self) -> None:
        self.append_html_text("<br>")
        self.append_html_text(
            "<b><pre> Port      Location      Vendor id  Product id  Manufacturer  Description<br></pre></b>"
        )
        ports = QSerialPortInfo.availablePorts()
        for port in ports:
            self.append_html_text(
                f"<pre> {port.portName():8}  {port.systemLocation():13} {str(port.vendorIdentifier()):10} {str(port.productIdentifier()):10}  {port.manufacturer():12}  {port.description()}<br></pre>"
            )

        self.append_html_text("<br>")

    def new_terminal(self) -> None:
        subprocess.Popen([f"{self_dir}/mpterm"], shell=False)


def list_ports() -> None:
    spi = QSerialPortInfo.availablePorts()
    for p in spi:
        print(f"{p.portName():<10}{p.description():<20}{p.systemLocation()}")


def main() -> None:
    logging_format = "[%(levelname)s] %(lineno)4d %(funcName)-16s : %(message)s"

    # options parsing
    parser = argparse.ArgumentParser(
        prog=App.NAME, add_help=True, description=App.DESCRIPTION
    )
    parser.add_argument(
        "--version", action="version", version=f"%(prog)s {App.VERSION}"
    )
    parser.add_argument("--info", action="store_true", help="Information about script")
    parser.add_argument(
        "--suspend", action="store_true", help="Send signal to suspend port temporary"
    )
    parser.add_argument("--list", action="store_true", help="List serialports")
    parser.add_argument("--debug", action="store_true", help="Activate debug printout")
    parser.add_argument(
        "--ext-program",
        action="store",
        type=str,
        dest="ext_program",
        help="Set external program to execute when signaled",
        default="",
    )
    parser.add_argument(
        "--exec-program",
        action="store_true",
        help="Send signal to initiate external program execution",
    )

    args = parser.parse_args()

    if args.debug:
        logging.basicConfig(format=logging_format, level=logging.DEBUG)

    if args.list:
        list_ports()
        sys.exit()

    if args.suspend:
        with os.popen(
            "ps aux | grep mpterm | grep -v -e 'grep' -e '--suspend'"
        ) as file:
            lines = file.readlines()

        for line in lines:
            pid = int(line.split()[1])
            logging.debug(f"Sending suspend signal to process pid={pid}")
            os.kill(pid, signal.SIGUSR1)

        sys.exit()

    if args.exec_program:
        with os.popen(
            "ps aux | grep mpterm | grep -v -e 'grep' -e '--exec-program'"
        ) as file:
            lines = file.readlines()

        for line in lines:
            pid = int(line.split()[1])
            logging.debug(f"Sending suspend signal to process pid={pid}")
            os.kill(pid, signal.SIGUSR2)

        sys.exit()

    app = QApplication(sys.argv)
    app.setStyle(
        "Fusion"
    )  # 'cleanlooks', 'gtk2', 'cde', 'motif', 'plastique', 'qt5ct-style', 'Windows', 'Fusion'
    app.setAttribute(Qt.AA_UseHighDpiPixmaps)

    mainForm = MainForm(args)
    mainForm.args = args
    mainForm.show()

    sys.exit(app.exec_())


# Main run_ext_program handle
if __name__ == "__main__":
    try:
        main()
        sys.exit(0)
    except KeyboardInterrupt as e:  # Ctrl-C
        raise e
    except SystemExit as e:  # sys.exit()
        raise e
    except Exception as e:
        print("ERROR, UNEXPECTED EXCEPTION")
        print(str(e))
        traceback.print_exc()
        os._exit(1)
